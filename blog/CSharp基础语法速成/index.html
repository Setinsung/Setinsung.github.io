<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>C#基础语法速成 - Setinsung</title>

  
    <meta name="description" content="这学期突然要学C#，那就学吧。以下笔记仅作自用">
<meta property="og:type" content="article">
<meta property="og:title" content="C#基础语法速成">
<meta property="og:url" content="https://setinsung.github.io/blog/CSharp%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E9%80%9F%E6%88%90/">
<meta property="og:site_name" content="Setinsung">
<meta property="og:description" content="这学期突然要学C#，那就学吧。以下笔记仅作自用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.imgtg.com/2023/03/02/VJyqq.jpg">
<meta property="og:image" content="https://i.imgtg.com/2023/03/02/VJgrc.jpg">
<meta property="article:published_time" content="2023-03-01T16:52:27.000Z">
<meta property="article:modified_time" content="2023-03-02T17:05:28.833Z">
<meta property="article:author" content="Setinsung">
<meta property="article:tag" content="C#">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i.imgtg.com/2023/03/02/VJyqq.jpg">
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="Setinsung" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="https://i.imgtg.com/2023/03/02/VJAbU.jpg">
  

  

  


  
    
      <link href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.css" rel="stylesheet">
    
  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://i.imgtg.com/2023/03/02/VJAbU.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Setinsung</div><div class="sub normal cap">重新开始一个博客</div><div class="sub hover cap" style="opacity:0"> 希望今年不会摆烂</div></a></div>

<nav class="menu dis-select"><a class="nav-item active" href="/">博客</a><a class="nav-item" href="/notes/">记录</a><a class="nav-item" href="/about/">更多</a></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="文章搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">C#基础语法速成</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-C-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-text">1.C#基本认识和特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Visual-Studio%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">2.Visual Studio的安装和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%BC%80%E5%A7%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE"><span class="toc-text">2.1 开始第一个项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-VS%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">2.2 VS的结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-cs%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">3.cs文件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-C-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">4.C#基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">4.1 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%B3%A8%E9%87%8A"><span class="toc-text">4.2 注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%8F%98%E9%87%8F"><span class="toc-text">4.3 变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-C-%E8%AF%AD%E6%B3%95%E8%BF%9B%E9%98%B6"><span class="toc-text">5.C#语法进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">5.1 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5"><span class="toc-text">5.2 分支语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%95%B0%E7%BB%84"><span class="toc-text">5.3 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">5.4 类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%87%BD%E6%95%B0"><span class="toc-text">5.5 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-1-%E5%8F%82%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">5.5.1 参数修饰符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88OOP%EF%BC%89"><span class="toc-text">6.面向对象编程（OOP）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">6.1 面向对象编程基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5"><span class="toc-text">6.2 类和对象概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">6.3 类的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">6.4 类和对象的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-%E5%A3%B0%E6%98%8E%E7%B1%BB"><span class="toc-text">6.4.1 声明类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-%E5%A3%B0%E6%98%8E%E5%B1%9E%E6%80%A7"><span class="toc-text">6.4.2 声明属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-3-%E5%A3%B0%E6%98%8E%E6%96%B9%E6%B3%95"><span class="toc-text">6.4.3 声明方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-4-%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">6.4.4 实例化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-5-%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8"><span class="toc-text">6.4.5 对象初始化器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-6-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">6.4.6 访问修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-7-static"><span class="toc-text">6.4.7 static</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%9B%86%E5%90%88-amp-%E5%AD%97%E5%85%B8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">7.集合&amp;字典的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">7.1 集合的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1-%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E5%8A%A3%E5%88%86%E6%9E%90"><span class="toc-text">7.1.1 数组的优劣分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2-ArrayList%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">7.1.2 ArrayList的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-3-%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">7.1.3 装箱与拆箱的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-4-List%E9%9B%86%E5%90%88"><span class="toc-text">7.1.4 List集合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%AD%97%E5%85%B8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">7.2 字典的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-foreach%E4%BD%BF%E7%94%A8"><span class="toc-text">7.3 foreach使用</span></a></li></ol></li></ol></div></div></widget>




</div>


    </aside>
    <div class='l_main'>
      

      


<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a></div><div id="post-meta">发布于&nbsp;<time datetime="2023-03-01T16:52:27.000Z">2023年3月2日</time></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>C#基础语法速成</span></h1>
<p>这学期突然要学C#，那就学吧。以下笔记仅作自用</p>
<span id="more"></span>

<h1 id="C-基础语法速成"><a href="#C-基础语法速成" class="headerlink" title="C#基础语法速成"></a>C#基础语法速成</h1><h2 id="1-C-基本认识和特点"><a href="#1-C-基本认识和特点" class="headerlink" title="1.C#基本认识和特点"></a>1.C#基本认识和特点</h2><ul>
<li>C#是微软公司发布的一种面向对象的、运行于 <strong>.NET Framework</strong> 和 <strong>.NET Core</strong> (完全开源，跨平台）之上的高级程序设计语言。</li>
<li>C#是一种安全的、稳定的、简单的、优雅的，由C和C++衍生出来的面向对象的编程语言。它在继承C和C++强大功能的同时去掉了一些它们的复杂特性。</li>
<li>C#是面向对象的编程语言。</li>
</ul>
<blockquote>
<ul>
<li>C#可以用指针，但是不推荐也少用了</li>
</ul>
</blockquote>
<p><strong>.NET和C#关系</strong></p>
<ul>
<li><strong>.NET是C#运行环境</strong>，C#是开发语言， C# 可以编写在.NET 中运行的应用程序。</li>
<li><strong>.NET公共语言运行时 (CLR)</strong> 是生成所有.NET 应用的基础，这个运行时还支持多种语言，有 C#、F# 和 Visual Basic 语言，但是C#算是主角</li>
</ul>
<hr>
<h2 id="2-Visual-Studio的安装和使用"><a href="#2-Visual-Studio的安装和使用" class="headerlink" title="2.Visual Studio的安装和使用"></a>2.Visual Studio的安装和使用</h2><ul>
<li><p>Microsoft Visual Studio（简称VS)是美国微软公司的开发工具包系列产品VS是一个基本完整的开发工具集，是编写C＃程序或者说NET程序最常用的开发工具。</p>
</li>
<li><p>下载vs网址：<a target="_blank" rel="noopener" href="https://visualstudio.microsoft.com/zh-hans/downloads/">https://visualstudio.microsoft.com/zh-hans/downloads/</a></p>
</li>
<li><p>vsi工作负载，根据自己的情况选择需要的安装模块，一般选择：ASP.NET和Web开发、.NET桌面开发、通用Windows平台开发、数据库存储和处理、Visual  Studio扩展开发、.NET Core跨平台开发</p>
</li>
</ul>
<hr>
<h3 id="2-1-开始第一个项目"><a href="#2-1-开始第一个项目" class="headerlink" title="2.1 开始第一个项目"></a>2.1 开始第一个项目</h3><ul>
<li>就不创建控制台程序了，直接创建一个windows窗体应用，就不搞控制台应用了</li>
<li>选择C#、Windows、桌面，找到 WPF 应用(.NET Framwork)</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.imgtg.com/2023/03/02/VJyqq.jpg" alt="VJyqq.jpg"></p>
<hr>
<h3 id="2-2-VS的结构"><a href="#2-2-VS的结构" class="headerlink" title="2.2 VS的结构"></a>2.2 VS的结构</h3><ul>
<li>一般习惯工具箱和解决方案资源管理器放在左边</li>
<li>别的好像也没啥了，随意了</li>
</ul>
<hr>
<h2 id="3-cs文件结构"><a href="#3-cs文件结构" class="headerlink" title="3.cs文件结构"></a>3.cs文件结构</h2><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.imgtg.com/2023/03/02/VJgrc.jpg" alt="VJgrc.jpg"></p>
<p><strong>上面程序的各个部分：</strong></p>
<ul>
<li><strong>using System</strong>： <strong>using 关键字</strong>：<strong>用于在程序中包含System命名空间</strong>。<strong>一个程序一般有多个using语句</strong>。</li>
<li><strong>namespace声明</strong>：<strong>一个namespace是一系列的类</strong>。WebApplication1命名空间 包含了类Program。</li>
<li><strong>class声明</strong>：<strong>类</strong>Program<strong>包含了程序使用的数据和方法声明</strong>。类一般包含多个方法，方法定义了类的行为。<strong>类只有一个Main方法</strong>。</li>
<li><strong>Main方法</strong>：是所有<strong>C#程序的入口点</strong>。Main方法说明当执行时类将做什么动作。</li>
<li>Main方法通过方法体中的语句指定它的行为。</li>
</ul>
<p><strong>以下几点值得注意</strong>：</p>
<ul>
<li>一个cs文件的结构大约是由以上几个部分组成，但是根据不同的需求和作用，<strong>会有不同的内容</strong></li>
<li>程序的<strong>执行从Main方法开始</strong></li>
</ul>
<hr>
<h2 id="4-C-基本语法"><a href="#4-C-基本语法" class="headerlink" title="4.C#基本语法"></a>4.C#基本语法</h2><ul>
<li><p>C#是一种<strong>面向对象</strong>的编程语言。在面向对象的程序设计方法中，程序由各种对象组成。相同种类的对象通常具有相同的类型。</p>
</li>
<li><p>C#是<strong>大小写敏感</strong>的</p>
</li>
<li><p>所有的语句和表达式必须<strong>以分号 <code>;</code> 结尾</strong></p>
</li>
<li><p>与Java不同的是，<strong>文件名可以不同于类的名称</strong></p>
</li>
</ul>
<h3 id="4-1-关键字"><a href="#4-1-关键字" class="headerlink" title="4.1 关键字"></a>4.1 关键字</h3><p>关键字，是<strong>对编译器有特殊意义</strong>的<strong>预定义保留标示符</strong>，它们<strong>不能在程序中用作标示符</strong></p>
<p><strong>using关键字</strong></p>
<ul>
<li>using关键字<strong>用于在程序中包含命名空间</strong>。一个程序可以包含多个using语句。</li>
<li>在任何C＃程序中的第一条语句都是：</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br></pre></td></tr></table></figure>

<p><strong>class关键字</strong></p>
<ul>
<li>class关键字用于声明一个类。</li>
</ul>
<hr>
<h3 id="4-2-注释"><a href="#4-2-注释" class="headerlink" title="4.2 注释"></a>4.2 注释</h3><ul>
<li><strong>块注释</strong></li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这个程序演示</span></span><br><span class="line"><span class="comment">C#语言的多行注释</span></span><br><span class="line"><span class="comment">语法*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>单行注释</strong>是用<code>//</code>符号表示。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>文档注释</strong>用<code>///</code>符号表示<ul>
<li>应用场合：<strong>声明的方法、类上</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 这是主程序入口</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;args&quot;&gt;</span>需要传入的参数<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释的作用：</p>
<ul>
<li><p>解释：说明代码作用</p>
</li>
<li><p>注销：将暂时不需要的代码注销</p>
</li>
</ul>
<p>总结：</p>
<ul>
<li>不写注释是流氓</li>
<li>名字瞎起是扯淡</li>
<li>相比注销，注释意义更大</li>
<li>要做到别人一看就能看懂</li>
</ul>
<hr>
<h3 id="4-3-变量"><a href="#4-3-变量" class="headerlink" title="4.3 变量"></a>4.3 变量</h3><ul>
<li>在C#中，每个变量都有一个特定的类型，不同类型的变量其内存大小也不尽相同。</li>
</ul>
<p><strong>C#的基本类型：</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>整数类型</td>
<td><strong>byte</strong>(0-255)、<strong>short</strong>(-32768-32767)、<strong>int</strong>(-2*10^9-2*10^9)、<strong>long</strong></td>
</tr>
<tr>
<td>浮点型</td>
<td><strong>float</strong>、<strong>double</strong></td>
</tr>
<tr>
<td>十进制类型</td>
<td><strong>decimal</strong></td>
</tr>
<tr>
<td>布尔类型</td>
<td><strong>bool</strong></td>
</tr>
<tr>
<td>字符类型</td>
<td><strong>string</strong>、<strong>char</strong></td>
</tr>
<tr>
<td>空类型</td>
<td><strong>null</strong></td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>float浮点类型，小数后需带f&#x2F;F</li>
<li>decimal相当于精度更大的浮点型，但会有更多的性能损耗</li>
<li>浮点型之间的转换只有float转换为double一种，decimal无法直接转换到浮点型</li>
</ul>
</blockquote>
<hr>
<h2 id="5-C-语法进阶"><a href="#5-C-语法进阶" class="headerlink" title="5.C#语法进阶"></a>5.C#语法进阶</h2><h3 id="5-1-表达式"><a href="#5-1-表达式" class="headerlink" title="5.1 表达式"></a>5.1 表达式</h3><ul>
<li><p>表达式由<strong>操作数</strong>(operand)和<strong>运算符</strong>(operator)构成。运算符的示例包括 <code>＋</code>、<code>-</code> 、<code>*</code>、<code>／</code> 和 <code>new</code>。操作数的示例包括<strong>文本</strong>、<strong>字段</strong>、<strong>局部变量</strong>和<strong>表达式</strong>。</p>
</li>
<li><p>当表达式包含多个运算符时，运算符的<strong>优先级</strong>(precedence)控制各运算符的计算顺序。例如，表达式x+y*z按x + (y * z)计算，因为＊运算符的优先级高于＋运算符。</p>
</li>
<li><p>（了解）大多数运算符都可以<strong>重载</strong>(overload,)。运算符重载允许指定用户定义的运算符实现来执行运算这些运算的操作数中至少有一个，甚至所有操作数都属于用户定义的类类型或结构类型。</p>
</li>
<li><p>下表总结了C＃简单常用的运算符，并按优先级从高到低的顺序列出各运算符类别。同一类别中的 运算符优先级相同。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类别</th>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>基本</strong></td>
<td>x.m</td>
<td>成员访问</td>
</tr>
<tr>
<td></td>
<td>x(…)</td>
<td>方法和委托调用</td>
</tr>
<tr>
<td></td>
<td>x[…]</td>
<td>数组和索引器访问</td>
</tr>
<tr>
<td></td>
<td>new T(…)</td>
<td>对象和委托创建</td>
</tr>
<tr>
<td></td>
<td>new T(…){…}</td>
<td>使用初始值设定项创建对象</td>
</tr>
<tr>
<td></td>
<td>new {…}</td>
<td>匿名对象初始值设定项</td>
</tr>
<tr>
<td></td>
<td>new T[…]</td>
<td>数组创建</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>类别</th>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>一元</strong></td>
<td>+x</td>
<td>恒等</td>
</tr>
<tr>
<td></td>
<td>-x</td>
<td>求相反数</td>
</tr>
<tr>
<td></td>
<td>!x</td>
<td>逻辑求反</td>
</tr>
<tr>
<td></td>
<td>~x</td>
<td>按位求反</td>
</tr>
<tr>
<td></td>
<td>++x</td>
<td>前增量</td>
</tr>
<tr>
<td></td>
<td>–x</td>
<td>前减量</td>
</tr>
<tr>
<td></td>
<td>x++</td>
<td>后增量</td>
</tr>
<tr>
<td></td>
<td>x–</td>
<td>后减量</td>
</tr>
<tr>
<td></td>
<td>(T)x</td>
<td>将x显式转换为类型T</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>类别</th>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>二元</strong></td>
<td>x*y、x&#x2F;y、x%y、x+y、x-y</td>
<td>乘除余加减（加号还有字符串串联）</td>
</tr>
<tr>
<td></td>
<td>x&lt;&lt;y、x&gt;&gt;y</td>
<td>位左移、位右移</td>
</tr>
<tr>
<td></td>
<td>x&lt;y、x&gt;y、x&lt;&#x3D;y、x&gt;&#x3D;y</td>
<td>小于、大于、小于等于、大于等于</td>
</tr>
<tr>
<td></td>
<td>x is T</td>
<td>如果x为类型T，则返回 true，否则返回false</td>
</tr>
<tr>
<td></td>
<td>x as T</td>
<td>返回转换为类型T的x，如果x不是T则返回null</td>
</tr>
<tr>
<td></td>
<td>x&#x3D;&#x3D;y、x!&#x3D;y</td>
<td>等于、不等于</td>
</tr>
<tr>
<td></td>
<td>x&amp;y、x|y</td>
<td>整型按位AND&#x2F;OR，布尔逻辑AND&#x2F;OR</td>
</tr>
<tr>
<td></td>
<td>x &amp;&amp; y</td>
<td>仅当x为true时，才对y求值</td>
</tr>
<tr>
<td></td>
<td>x ?? y</td>
<td>如果x为null，则计算结果为y，否则计算结果为x</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>类别</th>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>三元</strong></td>
<td>x?y:z</td>
<td>如果x为true，则对y求值；反之对z求值</td>
</tr>
<tr>
<td></td>
<td>x&#x3D;y</td>
<td>赋值</td>
</tr>
<tr>
<td></td>
<td>x&#x3D;x+y</td>
<td>复合赋值</td>
</tr>
<tr>
<td></td>
<td>(T x)&#x3D;&gt;y</td>
<td>匿名函数（lambda表达式）</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-2-分支语句"><a href="#5-2-分支语句" class="headerlink" title="5.2 分支语句"></a>5.2 分支语句</h3><p><strong>if语句</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">2</span>)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>switch语句</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        Console.WriteLine(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="literal">default</span>:</span><br><span class="line">        Console.WriteLine(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>for循环</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">    Console.WriteLine(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>while循环</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    i3++;</span><br><span class="line">    <span class="keyword">if</span> (i3 == <span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>这些看看就好了</li>
</ul>
</blockquote>
<hr>
<h3 id="5-3-数组"><a href="#5-3-数组" class="headerlink" title="5.3 数组"></a>5.3 数组</h3><ul>
<li>数组是<strong>一组相同类型</strong>的数据。</li>
<li>数组中的数据需要通过<strong>数字索引</strong>来访问。</li>
</ul>
<p><strong>数组的声明</strong></p>
<ul>
<li>数组的声明需要使用new关键字。</li>
<li>在声明数组时，可以使用｛｝来初始化数组中的元素。</li>
<li>如果在<strong>数组声明之初没有使用大括号来初始化数组中的元素，则需要指定数组的大小</strong>。</li>
<li>在<strong>声明初始化有元素的数组时，也可以指定数组大小</strong>。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明没有元素的数组</span></span><br><span class="line"><span class="built_in">int</span>[] arr1 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">6</span>];</span><br><span class="line"><span class="comment">// 声明初始化有元素的数组</span></span><br><span class="line"><span class="built_in">int</span>[] arr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">6</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="comment">// 在声明初始化有元素的数组时，也可以指定数组大小</span></span><br><span class="line"><span class="built_in">string</span>[] strings = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">3</span>] &#123; <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 不指定大小声明数组</span></span><br><span class="line"><span class="built_in">int</span>[] arr3 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>通过索引获取数组中的元素</strong></p>
<ul>
<li>给数组指定长度时，数组准备存放多少元素，长度就设置为多少</li>
<li>用索引获取数组内的元素时，索引从0开始获取。</li>
<li>所以数组中最大的索引数字，比指定数组长度小1。</li>
</ul>
<blockquote>
<ul>
<li>这些看看就好了</li>
</ul>
</blockquote>
<hr>
<h3 id="5-4-类型转换"><a href="#5-4-类型转换" class="headerlink" title="5.4 类型转换"></a>5.4 类型转换</h3><ul>
<li><code>(int)</code>表示使用<strong>显式强制转换</strong>，是一种类型转换，C#<strong>默认整型是int32</strong>，因此使用此方法转成int32位，不遵循四舍五入，于是<strong>只截取到了整数部分</strong><ul>
<li>(int)5.21 &#x2F;&#x2F;输出5</li>
</ul>
</li>
<li>①<strong>int.Parse()<strong>：</strong>只支持将string类型转成int</strong>，Parse就是把String类型转换成int、char、double等<ul>
<li>也就是***.Parse(string)括号中的一定要是string类型**。</li>
</ul>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String st = <span class="string">&quot;5.21&quot;</span>;</span><br><span class="line"><span class="built_in">double</span> n = <span class="number">5.21</span>;</span><br><span class="line"><span class="built_in">int</span>.Parse(st); <span class="comment">//输出5</span></span><br><span class="line"><span class="built_in">int</span>.Parse(n); <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<ul>
<li>②<strong>Convert.Tolnt32(double value)<strong>：</strong>不完全遵循四舍五入</strong>，如果<strong>value为两个整数中间的数字，则返</strong><br><strong>回二者中的偶数</strong></li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>Convert.Tolnt32() 和 int.Parset() <strong>对于空值(null)的处理不同</strong>，<strong>Convert.Tolnt32(nul)会返回0而不会产生任何异常，但int.Parse(null)则会产生异常</strong></li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(Convert.ToInt32(<span class="number">4.3</span>));<span class="comment">//四舍五入，输出4</span></span><br><span class="line">Console.WriteLine(Convert.ToInt32(<span class="number">4.5</span>));<span class="comment">//第一位小数为5时，4.5在4和5之间，输出偶数4</span></span><br><span class="line">Console.WriteLine(Convert.ToInt32(<span class="number">4.53</span>));<span class="comment">//四舍五入，输出5</span></span><br><span class="line">Console.WriteLine(Convert.ToInt32(<span class="number">5.3</span>));<span class="comment">//四舍五入，输出5</span></span><br><span class="line">Console.WriteLine(Convert.ToInt32(<span class="number">5.5</span>));<span class="comment">//第一位小数为5时，5.5在5和6之间，输出偶数6</span></span><br><span class="line">Console.WriteLine(Convert.ToInt32(<span class="number">5.53</span>));<span class="comment">//四舍五入，输出6</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="5-5-函数"><a href="#5-5-函数" class="headerlink" title="5.5 函数"></a>5.5 函数</h3><ul>
<li>函数好比是对象的<strong>动作行为</strong>。</li>
<li>在定义函数要想好函数所承担的作用，<strong>职责（作用）越单一越好</strong>。</li>
</ul>
<p><strong>函数命名规范</strong></p>
<ul>
<li>函数命名使用<strong>大驼峰命名</strong>，即开头<strong>首字母大写</strong></li>
<li>多个单词拼接时，所有单词<strong>首字母大写</strong></li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Add();</span><br><span class="line">AddCount();</span><br><span class="line">GetUserInfo();</span><br></pre></td></tr></table></figure>

<p><strong>函数的参数设置&amp;传参行为&amp;返回值</strong></p>
<ul>
<li>参数可认为是外部需要函数帮忙处理的数据。</li>
<li>外部通过传递参数的形式，将需要处理的数据交给函数处理。</li>
<li>函数返回值可以认为是外部调用某种行为后得到的一种反馈。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 加法方法</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;firstCount&quot;&gt;</span>数字1<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;secondCount&quot;&gt;</span>数字2<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> firstCount, <span class="built_in">int</span> secondCount</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> totle = firstCount + secondCount;</span><br><span class="line">    <span class="keyword">return</span> totle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-5-1-参数修饰符"><a href="#5-5-1-参数修饰符" class="headerlink" title="5.5.1 参数修饰符"></a>5.5.1 参数修饰符</h4><p>①<strong>无修饰符</strong>：如果一个参数<strong>没有用参数修饰符标记</strong>，则认为它将<strong>按值进行传递</strong>，这将意味着被调用的方法收到原始数据的一份<strong>副本</strong>。</p>
<ul>
<li>即上端调用方法后，下端修改传来的参数不会对原数据造成影响，即参数在方法中只复制了副本。</li>
</ul>
<p>示例：方法不对原字符串影响修改</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;test1&quot;</span>;</span><br><span class="line">SendMessage(str1);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendMessage</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span> &#123;</span><br><span class="line">    msg = <span class="string">&quot;change&quot;</span>;</span><br><span class="line">    Console.WriteLine(msg); <span class="comment">// change</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(str1); <span class="comment">// test1</span></span><br></pre></td></tr></table></figure>

<p>②<strong>out</strong>：<strong>输出参数由被调用的方法赋值</strong>，因此按<strong>引用传递</strong>，如果<strong>被调用的方法没有给输出参数赋值，就会出现编译错误</strong>。</p>
<ul>
<li>方法中out修饰的参数，一定要在方法内得到赋值</li>
<li>调用者可不赋初值，甚至<strong>可直接将声明变量写在方法调用传参中</strong></li>
<li>即上下端的参数指向同一个地址，修改都会受到影响。</li>
<li><strong>out最大的用途就是调用者只使用一次方法的调用就能获得多个返回值</strong>。</li>
<li>在C#7.0中要实现一次方法的调用就能获得多个返回值，<strong>建议使用元组</strong>。</li>
</ul>
<p>示例：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1.方法中的修改作用到原字符串 */</span></span><br><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;test1&quot;</span>;</span><br><span class="line">SendMessage(<span class="keyword">out</span> str1);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendMessage</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">string</span> msg</span>)</span> &#123;</span><br><span class="line">    msg = <span class="string">&quot;change&quot;</span>;</span><br><span class="line">    Console.WriteLine(msg); <span class="comment">// change</span></span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(str1); <span class="comment">// change</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.调用方法返回多个返回值 */</span></span><br><span class="line"><span class="comment">// 这里直接在方法调用的out参数上声明变量</span></span><br><span class="line"><span class="built_in">string</span> res = SellHouse(<span class="number">100</span>, <span class="number">1000</span>, <span class="keyword">out</span> <span class="built_in">string</span> wantPrice);</span><br><span class="line">Console.WriteLine(res);</span><br><span class="line">Console.WriteLine(wantPrice);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">SellHouse</span>(<span class="params"><span class="built_in">int</span> area, <span class="built_in">int</span> price, <span class="keyword">out</span> <span class="built_in">string</span> wantPrice</span>)</span> &#123;</span><br><span class="line">    wantPrice = <span class="string">&quot;出价&quot;</span> + (area * price - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;张三买房&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③<strong>ref</strong>：<strong>调用者必须赋初值</strong>，并且<strong>可以由被调用的方法可选的重新赋值</strong>（数据是按<strong>引用传递</strong>的）。如果被调用的方法<strong>未能给ref参数赋值，也不会有编译器错误</strong>。</p>
<ul>
<li>方法中ref修饰的参数，方法内未得到赋值不报错，和out不同。</li>
<li>但是调用者必须赋初值，否则报错。</li>
</ul>
<p>示例：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="comment">//string str1; 报错</span></span><br><span class="line">SendMessage(<span class="keyword">ref</span> str1);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendMessage</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">string</span> msg</span>)</span> &#123;</span><br><span class="line">    msg = <span class="string">&quot;test2&quot;</span>;</span><br><span class="line">    Console.WriteLine(msg); <span class="comment">// test</span></span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(str1); <span class="comment">// test</span></span><br></pre></td></tr></table></figure>

<ul>
<li>④<strong>params</strong>：这个参数修饰符允许将一组<strong>可变的数量的参数作为单独的逻辑参数进行传递</strong>，方法只能有一个params修饰符，而且<strong>必须是方法的最后一个参数</strong>。（就是可变参数）</li>
</ul>
<p><strong>总结out和ref的区别</strong></p>
<ul>
<li>out修饰的参数必须在方法内修改，而<strong>ref可以修改也可以不修改</strong></li>
<li><strong>out在传入参数的时候，参数是局部变量的话，可以不用赋值</strong>，因为out一定会对其进行赋值<ul>
<li>out参数方法中必须赋值，所以可不需要初始值</li>
</ul>
</li>
<li>而ref修饰的参数，在实参必须有初始值才能调用。因为<strong>ref修饰的不一定会给它赋值</strong><ul>
<li>因为方法中不一定给ref参数赋值，所以一定要有初始值</li>
</ul>
</li>
<li>out修饰参数可在调用方法时直接声明变量，ref则不行</li>
</ul>
<hr>
<h2 id="6-面向对象编程（OOP）"><a href="#6-面向对象编程（OOP）" class="headerlink" title="6.面向对象编程（OOP）"></a>6.面向对象编程（OOP）</h2><h3 id="6-1-面向对象编程基本概念"><a href="#6-1-面向对象编程基本概念" class="headerlink" title="6.1 面向对象编程基本概念"></a>6.1 面向对象编程基本概念</h3><ul>
<li><p>面向对象编程一一Object Oriented Programming简写<strong>OOP</strong></p>
</li>
<li><p>之前所接触到的编程方式叫做面向过程</p>
</li>
<li><p>面向过程和面向对象是两种不同的编程方式</p>
</li>
<li><p>对比面向过程的特点，可以更好的了解什么是面向对象</p>
</li>
</ul>
<p><strong>过程和函数</strong></p>
<ul>
<li><strong>过程</strong>是早期的一个编程概念</li>
<li><strong>过程类似于函数，只能执行，但是没有返回值</strong></li>
<li><strong>函数不仅能执行，还可以返回结果</strong></li>
</ul>
<p><strong>面向过程——强调怎么做？</strong></p>
<ul>
<li><p>把完成某一个需求的所有步骤从头到尾逐步实现</p>
</li>
<li><p>根据开发需求，将某些功能独立的代码封装成一个又一个函数</p>
</li>
<li><p>最后完成的代码，就是顺序的调用不同的函数</p>
</li>
<li><p><strong>特点：</strong></p>
<ul>
<li><strong>注重步骤与过程，不注重职责分工</strong></li>
<li>如果需求复杂，代码会变得很复杂</li>
<li><strong>复杂项目，没有固定的套路，难度很大</strong></li>
<li>比如一个主函数，自顶向下调用多个子函数，这几个子函数又会去调用多个子子函数，形成树的结构</li>
</ul>
</li>
</ul>
<p><strong>面向对象逻辑——强调谁来做？</strong></p>
<ul>
<li><p>相比较函数，<strong>面向对象是更大的封装</strong>，根据职责，<strong>在一个对象中封装多个方法</strong></p>
</li>
<li><p>在完成某一个需求前，首先确定职责，要做的事情（方法）</p>
</li>
<li><p>根据职责确定不同的对象，在对象内部封装不同的方法（多个）</p>
</li>
<li><p>最后完成代码，就是顺序的让<strong>不同的对象调用不同的方法</strong></p>
</li>
<li><p><strong>特点：</strong></p>
<ul>
<li><p><strong>注重对象和职责，不同的对象承担不同的职责</strong></p>
</li>
<li><p>更加适合应对复杂的需求变化，是<strong>专门应对复杂项目开发，提供固定套路</strong></p>
</li>
<li><p>需要在面向过程基础上，再学习一些面向对象的语法</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-2-类和对象概念"><a href="#6-2-类和对象概念" class="headerlink" title="6.2 类和对象概念"></a>6.2 类和对象概念</h3><ul>
<li><p><strong>类</strong>和<strong>对象</strong>是面向对象编程的两个<strong>核心概念</strong></p>
</li>
<li><p>类是对一群具有相同特征或者行为的事物的一个统称，是<strong>抽象的，不能直接使用</strong></p>
<ul>
<li><strong>特征被称为属性</strong></li>
<li><strong>行为被称为方法</strong></li>
</ul>
</li>
<li><p>例如：类相当于制汽车是的图纸，是一个模板，是负责创建对象的</p>
</li>
</ul>
<p><strong>对象</strong></p>
<ul>
<li><strong>对象是由类创造出来的一个具体存在</strong>，可以直接使用</li>
<li>由<strong>哪一个类</strong>创造出来的<strong>对象</strong>，就拥有在哪一个类中定义的<strong>属性</strong>和<strong>方法</strong></li>
<li>对象就相当于用图纸制造的汽车</li>
</ul>
<blockquote>
<ul>
<li>先有类，再有对象</li>
</ul>
</blockquote>
<p><strong>类和对象的关系</strong></p>
<ul>
<li><strong>类是模板</strong>，对象是根据类这个<strong>模板创建</strong>出来的，应该先有类，再有对象</li>
<li>类只有一个，而对象可以有很多个<ul>
<li><strong>不同的对象之间属性的具体内容可能各不相同</strong></li>
</ul>
</li>
<li><strong>类中定义了什么属性和方法，对象中就有什么属性和方法，不可能多，也不可能少</strong></li>
</ul>
<hr>
<h3 id="6-3-类的设计"><a href="#6-3-类的设计" class="headerlink" title="6.3 类的设计"></a>6.3 类的设计</h3><ul>
<li>在使用面向对象开发前，应该首先分析需求，确定一下程序中需要包含哪些类</li>
</ul>
<p>在程序开发中要设计一个类，通常需要满足以下三个要素：</p>
<ul>
<li>1.<strong>类名</strong>这类事物的名称，满足大驼峰命名法</li>
<li>2.<strong>属性</strong>这类事物具有什么样的特征</li>
<li>3.<strong>方法</strong>这类事物具有什么样的行为</li>
</ul>
<p><strong>类名的确定</strong></p>
<ul>
<li><strong>名词提炼法</strong>分析<strong>整个业务流程</strong>，出现的<strong>名词</strong>，通常就是找到的<strong>类</strong>。</li>
</ul>
<p><strong>属性和方法的确定</strong></p>
<ul>
<li>对<strong>对象的特征</strong>，描述通常可以定义成属性。</li>
<li><strong>对象具有的行为</strong>通常可以定义为<strong>方法</strong>。注：<strong>方法一般是动作即动词</strong></li>
</ul>
<blockquote>
<ul>
<li>提示：需求没有涉及的属性或者方法在设计类时，不需要考虑，即可忽略。</li>
</ul>
</blockquote>
<hr>
<h3 id="6-4-类和对象的使用"><a href="#6-4-类和对象的使用" class="headerlink" title="6.4 类和对象的使用"></a>6.4 类和对象的使用</h3><h4 id="6-4-1-声明类"><a href="#6-4-1-声明类" class="headerlink" title="6.4.1 声明类"></a>6.4.1 声明类</h4><ul>
<li>声明一个类需要使用<strong>class</strong>关键字</li>
<li>类的属性及方法写在<code>&#123;&#125;</code>中</li>
<li>步骤：vs中右键项目名——添加——类</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-4-2-声明属性"><a href="#6-4-2-声明属性" class="headerlink" title="6.4.2 声明属性"></a>6.4.2 声明属性</h4><ul>
<li><p>属性在C#中较为独特，它<strong>既不同于方法，也不同于字段</strong>。</p>
</li>
<li><p>属性依旧遵循大驼峰命名法</p>
</li>
<li><p>属性最常用的书写方法：<code>public int Age &#123;get; set;&#125;</code></p>
</li>
<li><p>如果<strong>属性中具有get关键字，说明可以获取该属性的值</strong>。</p>
</li>
<li><p>如果<strong>属性中具有set关键字，说明可以向该属性设置值</strong>。</p>
</li>
<li><p>如果没有get和set关键字，则无法获取属性值以及设置属性值</p>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Csharp_Class</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Height &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>vs快捷编码 - <strong>自动属性模板</strong>：输入props，按2次Tab，自动生成一个属性声明的模板</li>
</ul>
</blockquote>
<h4 id="6-4-3-声明方法"><a href="#6-4-3-声明方法" class="headerlink" title="6.4.3 声明方法"></a>6.4.3 声明方法</h4><ul>
<li>详见函数初识</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Csharp_Class</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Height &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span> &#123;</span><br><span class="line">            MessageBox.Show(<span class="string">&quot;吃&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>()</span> &#123;</span><br><span class="line">            MessageBox.Show(<span class="string">&quot;跑&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-4-4-实例化"><a href="#6-4-4-实例化" class="headerlink" title="6.4.4 实例化"></a>6.4.4 实例化</h4><ul>
<li><strong>类使用关键字<code>new</code>实例化对象</strong>。</li>
<li>一个类可以实例化多个对象。</li>
<li>对象可以使用类定义的属性和方法。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在另一个类中实例化前面的类，并使用 */</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Csharp_Class</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span> &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form1_Load</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">            Person p = <span class="keyword">new</span> Person();</span><br><span class="line">            p.Name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">            p.Age = <span class="number">29</span>;</span><br><span class="line">            p.Eat();</span><br><span class="line">            p.Run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-4-5-对象初始化器"><a href="#6-4-5-对象初始化器" class="headerlink" title="6.4.5 对象初始化器"></a>6.4.5 对象初始化器</h4><ul>
<li><p>在实例化之时，就对其属性进行赋值。</p>
</li>
<li><p>即实例化后直接跟随一个大括号，其中写明属性的赋值，注意这之中分隔符为逗号</p>
</li>
<li><p>可以不带括号了，直接连接大括号</p>
</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在另一个类中实例化前面的类，并使用 */</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Csharp_Class</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span> &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form1_Load</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// 拓展：对象初始化器：在实例化之时，就对其属性进行赋值</span></span><br><span class="line">            Person p2 = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">                Age = <span class="number">18</span>,</span><br><span class="line">                Name = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-4-6-访问修饰符"><a href="#6-4-6-访问修饰符" class="headerlink" title="6.4.6 访问修饰符"></a>6.4.6 访问修饰符</h4><ul>
<li><p><strong>public</strong>：公有的所有的类都可以访问</p>
</li>
<li><p><strong>private</strong>：私有的当前类内部可访问</p>
</li>
<li><p><strong>protected</strong>：受保护的当前类以及继承他的子类可访问</p>
</li>
<li><p><strong>internal</strong>：内部的只限于本项目内访问，其他的不能访问。</p>
</li>
<li><p><strong>protected internal</strong>：内部保护访问只能是本项目内部或子类访问其他类不能访问</p>
</li>
<li><p><strong>访问级别约束</strong>：</p>
<ul>
<li><strong>父类子类访问修饰符要保持一致</strong></li>
<li><strong>方法的访问修饰符 要和 方法参数的访问修饰符 保持一致</strong></li>
</ul>
</li>
<li><p><strong>注意</strong>：<strong>类的访问级别</strong> <strong>默认为隐式私有</strong>，因此<strong>需要加上public才可让外部访问</strong></p>
</li>
</ul>
<h4 id="6-4-7-static"><a href="#6-4-7-static" class="headerlink" title="6.4.7 static"></a>6.4.7 static</h4><ul>
<li><strong>静态方法、属性</strong><ul>
<li>静态属性和方法 通过**<code>static</code>关键字**修饰</li>
<li>静态属性和方法 <strong>可以通过类型直接获取</strong>，<strong>非静态则必须通过实例化的对象获取</strong></li>
</ul>
</li>
<li><strong>静态类</strong><ul>
<li>静态类通过**<code>static</code>关键字**修饰</li>
<li>一般情况下类型不需要使用静态修饰，只有当类型中存在扩展方法时需要使用<strong>静态类</strong></li>
</ul>
</li>
</ul>
<hr>
<h2 id="7-集合-amp-字典的使用"><a href="#7-集合-amp-字典的使用" class="headerlink" title="7.集合&amp;字典的使用"></a>7.集合&amp;字典的使用</h2><h3 id="7-1-集合的使用"><a href="#7-1-集合的使用" class="headerlink" title="7.1 集合的使用"></a>7.1 集合的使用</h3><ul>
<li><strong>集合与数组比较类似</strong>，<strong>都用于存放一组值</strong></li>
</ul>
<h4 id="7-1-1-数组的优劣分析"><a href="#7-1-1-数组的优劣分析" class="headerlink" title="7.1.1 数组的优劣分析"></a>7.1.1 数组的优劣分析</h4><p><strong>优势</strong></p>
<ul>
<li>数组在<strong>内存中是连续存储</strong>的，所以它的<strong>索引速度是非常的快</strong>，而且赋值与修改元素也很简单。</li>
</ul>
<p><strong>劣势</strong></p>
<ul>
<li>在数组的<strong>两个数据间插入数据很麻烦</strong></li>
<li>在<strong>声明数组</strong>的时候，<strong>必须同时指明数组的长度</strong>，<strong>数组的长度过长，会造成内存浪费，数组和长度过短，会造成数据溢出的错误</strong></li>
</ul>
<h4 id="7-1-2-ArrayList的使用"><a href="#7-1-2-ArrayList的使用" class="headerlink" title="7.1.2 ArrayList的使用"></a>7.1.2 ArrayList的使用</h4><ul>
<li><strong>ArrayList</strong>是 <strong>.NET Framework</strong> 提供的<strong>用于数据存储和检索的专用类</strong></li>
<li>它是命名空间 <strong>System.Collections</strong>下的一部分</li>
</ul>
<p><strong>ArrayList的优势</strong></p>
<ul>
<li><p>ArrayList的<strong>大小是按照其中存储的数据来动态扩充与收缩的</strong></p>
</li>
<li><p>在<strong>声明</strong> ArrayList 对象时并<strong>不需要指定它的长度</strong></p>
</li>
<li><p>ArrayList可以很<strong>方便的进行数据的添加，插入和移除</strong></p>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.Add(<span class="number">123</span>);</span><br><span class="line">arrayList.Add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">arrayList.Insert(<span class="number">1</span>, <span class="number">123</span> + <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">arrayList.RemoveAt(<span class="number">0</span>);</span><br><span class="line">arrayList.Remove(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>从上面示例看，ArrayList好像是解决了数组中所有的缺点，那么它应该就是完美的。 可是<strong>在C#2.0 后又出现了List集合</strong>，这是为何？</li>
</ul>
</blockquote>
<p><strong>ArrayList的劣势</strong></p>
<ul>
<li><p>ArrayList在<strong>存储数据时时是使用 object类型 进行存储的</strong></p>
<ul>
<li>object是所有类的父类（父类可接收子类的对象）</li>
</ul>
</li>
<li><p>ArrayList<strong>不是类型安全的</strong>，使用时<strong>很可能会出现类型不匹配的错误</strong></p>
</li>
<li><p>就算都有插入了统一类型的数据，但在使用的时候，也需要将它们从object转化为对应的原类型来处理</p>
</li>
<li><p><strong>ArrayList的存储存在 装箱 和 拆箱 操作，导致其性能低下</strong></p>
</li>
</ul>
<h4 id="7-1-3-装箱与拆箱的概念"><a href="#7-1-3-装箱与拆箱的概念" class="headerlink" title="7.1.3 装箱与拆箱的概念"></a>7.1.3 装箱与拆箱的概念</h4><ul>
<li><strong>装箱</strong>：将比如int类型或者string等 <strong>不同类型的对象</strong> 通过 <strong>隐式转换</strong> <strong>赋给object对象</strong>。（子赋给父）</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">object</span> o = i;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>拆箱</strong>：将 <strong>object对象</strong> 通过<strong>显式转换</strong> <strong>赋给int类型的变量</strong>（父转换为子）<ul>
<li>显式转换的前提是，被转换者的类型确实是这个类型。否则报错</li>
</ul>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> o = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">int</span> i = (<span class="built_in">int</span>)o;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>装箱与拆箱的过程会产生较多的性能损耗</strong>。</li>
<li>正是因为<strong>ArrayList</strong>存在 <strong>不安全类型</strong> 与 <strong>装箱拆箱</strong> 的缺点，所以在<strong>C#2.0后出现了泛型的概念</strong>。</li>
<li>泛型的概念在此先不多做表述，可以简单理解成：<strong>限制集合只能够存储单一类型数据的一种手段</strong></li>
</ul>
<h4 id="7-1-4-List集合"><a href="#7-1-4-List集合" class="headerlink" title="7.1.4 List集合"></a>7.1.4 List集合</h4><ul>
<li>目前只学习List集合这一种类型即可，以此为突破口，以后再学习其他集合就会非常容易</li>
</ul>
<p><strong>List集合的声明</strong></p>
<ul>
<li><p>List集合与ArrayList由于都继承成了相同的接口，故<strong>使用与ArrayList相似</strong>。</p>
</li>
<li><p><strong>在声明List集合时，需要同时为其声明List集合内数据的对象类型</strong></p>
</li>
<li><p>示例：<code>List&lt;int&gt; intList = new List&lt;int&gt;()</code></p>
</li>
</ul>
<blockquote>
<ul>
<li><strong>接口</strong>：限制和规定类型行为即类型方法的一种手段。</li>
</ul>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; ints = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">ints.Add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//ints.Add(&quot;abc&quot;);</span></span><br><span class="line">ints[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">ints[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">ints.Insert(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">ints.RemoveAt(<span class="number">0</span>);</span><br><span class="line">ints.Remove(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 对象初始化器方式</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; ints2 = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123;</span><br><span class="line">    <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line">ints2.Clear();</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>上例中，如果往List集合中插入string字符串”abc”，系统就会报错，且不能通过编译。这样就<strong>避免了前面讲的类型安全问题与装箱拆箱的性能问题</strong></li>
</ul>
</blockquote>
<p><strong>在List集合中使用自己创建的类</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Height &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; people = <span class="keyword">new</span> List&lt;Person&gt;();</span><br><span class="line">Person person1 = <span class="keyword">new</span> Person &#123;</span><br><span class="line">    Age = <span class="number">18</span>,</span><br><span class="line">    Height = <span class="number">178</span>,</span><br><span class="line">    Name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">people.Add(person1);</span><br><span class="line">people.Add(person1);</span><br><span class="line">people.Add(<span class="keyword">new</span> Person &#123;</span><br><span class="line">    Age = <span class="number">18</span>,</span><br><span class="line">    Height = <span class="number">178</span>,</span><br><span class="line">    Name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line">Person person2 = people[<span class="number">0</span>];</span><br><span class="line">people.RemoveAt(<span class="number">0</span>);</span><br><span class="line">people.Remove(person1);</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>注意remove方法删除的是指定地址的对象，而每次new出来的对象即使属性相同但是地址不同，还是不同的对象，那么就不能同时被删除掉</li>
</ul>
</blockquote>
<p><strong>总结</strong></p>
<ul>
<li><p>集合与数组比较类似，都用于存放<strong>一组值</strong></p>
</li>
<li><p>集合中提供了特定的方法能直接操作集合中的数据，并提供了不同的集合类来实现特定的功能</p>
</li>
<li><p>简单的说就是数组的升级版。 他可以动态的对集合的长度（也就是集合内最大元素的个数）进行定义和维护</p>
</li>
<li><p>List泛型的好处指通过允许指定 <strong>泛型类或方法</strong> 操作的 <strong>特定类型</strong>， 减少了类型 <strong>强制转换</strong> 的需要和运行时错误的可能性，<strong>泛型提供了类型安全，但没有增加开销</strong>。（不会发生装箱和拆箱）</p>
</li>
</ul>
<hr>
<h3 id="7-2-字典的使用"><a href="#7-2-字典的使用" class="headerlink" title="7.2 字典的使用"></a>7.2 字典的使用</h3><ul>
<li><p>即一个萝卜一个坑，每一个标记有不重复编号的坑都只能放一个萝卜或者其它东西</p>
</li>
<li><p>Dictionary有 <code>key</code>(键) 和 <code>value</code>(值)，<strong>一个键只能对应一种值</strong></p>
</li>
<li><p>一个value可以有很多key，但是key是唯一的。</p>
<ul>
<li>比如学生是唯一的，成绩不唯一</li>
</ul>
</li>
<li><p><strong>总结：键唯一，值不唯一</strong></p>
</li>
</ul>
<p><strong>Dictionary声明</strong></p>
<ul>
<li>在声明Dictionary字典时，需要<strong>同时为其声明Dictionary字典内键与值的类型</strong>。</li>
<li>示例：<code>Dictionary&lt;int,string&gt; dictionary = new Dictionary&lt;int, string&gt;()</code></li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line"><span class="comment">// 方式一：Add方法赋值</span></span><br><span class="line">dictionary.Add(<span class="number">1</span>, <span class="string">&quot;98分&quot;</span>);</span><br><span class="line">dictionary.Add(<span class="number">2</span>, <span class="string">&quot;92分&quot;</span>);</span><br><span class="line">dictionary.Add(<span class="number">3</span>, <span class="string">&quot;89分&quot;</span>);</span><br><span class="line">dictionary.Add(<span class="number">1</span>, <span class="string">&quot;88分&quot;</span>); <span class="comment">// 运行后系统会报错（重复键）</span></span><br><span class="line"><span class="comment">// 方式二：索引器赋值</span></span><br><span class="line">dictionary[<span class="number">1</span>] = <span class="string">&quot;88分&quot;</span>; <span class="comment">//系统不报错</span></span><br><span class="line">dictionary[<span class="number">4</span>] = <span class="string">&quot;99分&quot;</span>;</span><br><span class="line"><span class="comment">// 方式三：对象初始化器</span></span><br><span class="line">Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; dictionary2 = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; &#123;</span><br><span class="line">    &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;aa&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;B&quot;</span>, <span class="string">&quot;bb&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;C&quot;</span>, <span class="string">&quot;cc&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Dictionary取值和删除</strong></p>
<ul>
<li>Dictionary索引器中写的键，获取到的是单个的对应值</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取键为1的值</span></span><br><span class="line"><span class="comment">// 方式一：索引器取值</span></span><br><span class="line"><span class="built_in">string</span> <span class="keyword">value</span> = dictionary[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：foreach遍历取值（这里遍历项就是每一个小键值对，用KeyValuePair专门定义可设置或检索的键值对）</span></span><br><span class="line"><span class="keyword">foreach</span> (KeyValuePair&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; item <span class="keyword">in</span> dictionary) &#123;</span><br><span class="line">    <span class="built_in">string</span> value2 = item.Value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除键为1的键值对</span></span><br><span class="line">dictionary.Remove(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li><strong>键与值可以是任何类型， 但是键必须在设置时是唯一的， 而值可以不唯一</strong></li>
<li>使用Add(）方法添加键值对，<strong>不可添加已有的键名</strong></li>
<li><strong>索引模式可以 新赋值 也可以 修改 已有的键值</strong>（<strong>注意不是下标</strong>）</li>
<li><strong>字典是键值对的集合</strong></li>
</ul>
<hr>
<h3 id="7-3-foreach使用"><a href="#7-3-foreach使用" class="headerlink" title="7.3 foreach使用"></a>7.3 foreach使用</h3><ul>
<li>foreach就是传说中的<strong>增强for循环</strong>或者称作<strong>foreach循环</strong></li>
<li>foreach<strong>对遍历字典或集合具备天然优势</strong>， <strong>效率高过for循环</strong><ul>
<li>它循环的对象继承了迭代器</li>
</ul>
</li>
</ul>
<p><strong>foreach操作数组</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] ints = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> item <span class="keyword">in</span> ints) &#123;</span><br><span class="line">    <span class="comment">// 每次循环，其item都是整型数组中的一个元素</span></span><br><span class="line">    MessageBox.Show(item.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>foreach操作集合</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; intList = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> item <span class="keyword">in</span> intList) &#123;</span><br><span class="line">    <span class="comment">// 每次循环，其item都是List集合中的一个元素</span></span><br><span class="line">    MessageBox.Show(item.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>foreach操作字典</strong></p>
<ul>
<li>这里的item就是一个小键值对</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (KeyValuePair&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; item <span class="keyword">in</span> dictionary) &#123;</span><br><span class="line">    <span class="built_in">int</span> key0 = item.Key;</span><br><span class="line">    <span class="built_in">string</span> value0 = item.Value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用var类型推断</strong></p>
<ul>
<li>var关键字的作用是<strong>推断类型</strong>，<strong>声明的时候必须赋值</strong>。赋值到什么类型就成为什么类型</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; listInt = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> listInt)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<ul>
<li>那么至此C#大概常用的简单语法就学完了</li>
</ul>
</blockquote>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/blog/%E4%BD%BF%E7%94%A8vscode%E7%BC%96%E5%86%99CSharp/">使用vscode编写C#代码</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/blog/%E5%BC%80%E5%A7%8B/">开始</a></div></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本站由 <a href="/">@anonymity</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.18.5';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
