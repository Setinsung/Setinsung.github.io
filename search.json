[{"title":"UserAgent判断判断移动端","path":"/blog/2023-09-15-web/","content":"UserAgent判断判断移动端时的问题举例和解决方案 1.案例 一些网站如尘白禁区官网https://www.cbjq.com/，一般情况下显示也正常，但是如果在Ubuntu下访问，就会被重定向到https://www.cbjq.com/m/，导致错误的显示。 查看网页源代码，就可以容易地看到下面的js代码，也就是这段代码出现了bug。 2.代码 这是使用了userAgent判断浏览器类型，在网上可以找到很多类似以下的代码，判断android设备时，同时判断了userAgent中是否包含”Android”和”Linux”。不知道为啥注释都有”或者uc浏览器”。 虽然安卓设备的userAgent中确实有”Linux”，但是这样的判断有时会导致问题。不过可能也是因为linux浏览器的userAgent比较小众，不是主流的浏览器，所以被忽略了。那就需要手动改userAgent去访问了。 1234567891011121314151617181920212223var browser = &#123; versions: function () &#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123; trident: u.indexOf(&#x27;Trident&#x27;) &gt; -1, //IE内核 presto: u.indexOf(&#x27;Presto&#x27;) &gt; -1, //opera内核 webKit: u.indexOf(&#x27;AppleWebKit&#x27;) &gt; -1, //苹果、谷歌内核 gecko: u.indexOf(&#x27;Gecko&#x27;) &gt; -1 &amp;&amp; u.indexOf(&#x27;KHTML&#x27;) == -1,//火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf(&#x27;Android&#x27;) &gt; -1 || u.indexOf(&#x27;Linux&#x27;) &gt; -1, //android终端或者uc浏览器 iPhone: u.indexOf(&#x27;iPhone&#x27;) &gt; -1, //是否为iPhone或者QQHD浏览器 iPad: u.indexOf(&#x27;iPad&#x27;) &gt; -1, //是否iPad webApp: u.indexOf(&#x27;Safari&#x27;) == -1, //是否web应该程序，没有头部与底部 weixin: u.indexOf(&#x27;MicroMessenger&#x27;) &gt; -1, //是否微信 （2015-01-22新增） qq: u.match(/\\sQQ/i) == &quot; qq&quot; //是否QQ &#125;; &#125;(), language: (navigator.browserLanguage || navigator.language).toLowerCase()&#125;if (browser.versions.mobile || browser.versions.android || browser.versions.ios) &#123; window.location.href = goUrl&#125; 另外一段常见的判断userAgent是否为移动端的代码，没有以上的bug，但是也不够精确 1navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i) 3.说明 实际上检测userAgent判断设备类型这种方法不够可靠，现在也不被推荐。由于用户代理可以被伪造或修改，也会导致错误判断。 现在更常见的方法是使用媒体查询和响应式设计来适应不同的设备。 通过使用CSS和HTML的媒体查询功能，根据设备屏幕大小、分辨率和方向等特征来自动调整网站的布局和样式。这种方法更加灵活和可靠，而无需依赖用户代理。 或者说使用一些判断设备类型的js库，比如react-device-detect、current-device等","tags":["Web"],"categories":["Web"]},{"title":"Nodejs卸载并使用nvm","path":"/blog/2023-08-24-nodejs/","content":"对nodejs的版本进行了卸载，改为使用nvm版本管理 1.卸载nodejs 直接在win菜单中搜索uninstall node.js，点击卸载即可。 然后删除所有相关文件夹，如npm的cache文件夹和global存储文件夹。防止出现问题 2.下载和使用nvm 实际上这个工具的名称是NVM for Windows，使用Go语言编写，与在Linux上的NVM不同。允许用户在Windows系统上同时安装和管理多个Node.js版本，并能够轻松切换版本。 直接下载安装nvm-setup.exe 检查安装是否成功 1nvm ls 安装最新稳定版nodejs，并使用该版本 12nvm install stable nvm ues xx.xx.x 查看node版本，可见安装成功 1node -v","tags":["Nodejs"],"categories":["Nodejs"]},{"title":"整理一遍博客","path":"/blog/2023-08-24-journal/","content":"重新整理一遍博客，再次开始 博客整理的思考今天重新整理了一遍博客，这学期时间多起来了应该更有时间去写了。之后打算没啥用的日记越少越好，笔记可以多写点，没了。","tags":["journal"],"categories":["日记"]},{"title":"时间和摸鱼","path":"/blog/2023-04-15-journal/","content":"时间一多就想摸鱼，摸完时间少了就摆了 时间和摸鱼最近事情有点多，好像时间越来越少了。 突然想到的一句话：时间一多就想摸鱼，摸完时间少了就摆了。 比如说周末时间多起来了，人就更懒了，可能只是我是这样的人。消耗了很多时间了之后，发现没什么时间了，又会觉得要不就算了，反正也没多少时间了。于是，这样的循环就使时间越来越少，最后什么事都完成不了，或者是开始时有干劲，但是一看到完成事件还需要很长很长一段路要走时，就准备半途而废了。 那么，如何解决这种问题呢？ 我认为还是得调整好心态，不要因为消耗时间后悔，及时改过补上就好了。而对于那些感觉需要花很长时间才能完成的事，半途而废太可惜了，还是那句话，日积月累啊","tags":["journal"],"categories":["日记"]},{"title":"一次游戏汉化","path":"/blog/2023-03-29-journal/","content":"记录一次游戏汉化 原因汉化一个游戏是我从来没想过的。汉化的游戏是一个多人本地联机游戏，之前寻找的远程联机手段也是为了玩这个游戏。 但是，虽然找到了远程联机的方法，游戏本身没有中文，还是有些不太好。这个游戏已经5年以上了，一直没有中文，也没有人去汉化。于是就想到了自己去汉化。 事实上在3月初时就已经开始在了解相关的东西，但是由于不太懂，断断续续地进行了尝试。而2个星期前算是正式开始汉化。刚开始的准备工作还是去找相关的方法和教程，但是这个汉化的方法真的是网上没几个。不过最后还是通过各种教程、询问他人和自己的瞎折腾不断尝试成功了。 虽然这个游戏体量不大，内容和条目也不算多，但是一个人去汉化还是比较麻烦的，那几天花费了大部分的空闲时间去汉化这个游戏。反正就是想早点搞完为好。 工具汉化使用到的工具太多了，有些工具可以做这件事，但是却不能做那件事之类的，往往要好多个工具同时使用。比如使用dnSpy反编译游戏的dll去找对应的代码然后修改替换，使用AssetStudio找游戏的静态资源，以及AssetBundleExtractor来对资源的导入导出，UnityEX对游戏字体的导入导出，FontCreator对字体文件的修改等等。对于字体，由于Crawl的字体是那种像素的英文字体，而且非常小，网上找的免费字体都不太匹配游戏的原文，于是自己买了个中文像素字体，分别有7px和9px版的，这样就和原游戏十分适配了。（这应该是汉化这个游戏花费的全部金钱了） 问题比如AssetBundleExtractor软件本身的bug，使用JSON格式导入导出对转义字符的输出有问题。那就需要换用txt格式导入导出。 用python脚本把json文件的部分文本获取然后修改再导回去出现了bug。后来才发现这是代码写拉了，没想到游戏直接崩了。 unity的text不支持中文的自动换行，将中文识别为一整个英文单词，导致汉化后变成一行直接超出屏幕。这个有好几种办法，比如可以用FontCreator把游戏字体里的空格字符修改得非常小，然后用脚本把每处修改文本的每个字都加上空格，这样进入游戏后就不会显示出空格也能支持换行了。 除此之外，还有很多非常奇怪的坑，应该是经验不足搞半天，反正最后还是解决了所有的问题。 最后最后也是把最复杂的武器、武器词条、武器魔法、武器描述汉化完成了，有些文本找不到也没办法，有些是游戏直接做的贴图和动画，就没去弄的。总体来说大部分的直接关乎提高游戏体验的内容是汉化了，比如游戏主界面选项、设置选项、章节文本、道具名称和描述、武器名称和描述、武器随机词条、随机魔法等。 还有一点东西可以汉化，但是目前就暂告一段落了。毕竟这不是正事，只是一个为了让朋友和自己玩起来更爽才搞的，顺便帮助到了有同样困难的人，虽然这个游戏十分冷门但，但是好玩，汉化也许能稍微增加些玩家吧。","tags":["journal"],"categories":["日记"]},{"title":"C#之模拟简单的IOC容器练习","path":"/blog/2023-03-16-csharp-ioc/","content":"C#之模拟简单的IOC容器练习，只模拟实现一小部分的功能 1.结构和步骤准备步骤 创建ServiceLife服务生命周期枚举 创建服务描述类ServiceDescriptor，分为三种生命周期 创建ServiceCollection容器集合，用于添加和存储服务描述类实例 创建ServiceProvider根节点服务提供类，使用时声明为static 创建ServiceFactory容器工厂，用于通过容器集合创建根节点服务提供类实例 创建ServiceProviderScoped作用域服务提供类，也通过工厂用根节点服务提供类创建，用于获取作用域生命周期服务 准备 新建一个类库项目IocDemo，用于模拟IOC容器 新建一个WebAPI项目，用于测试自己写的容器 2.MyServiceLife 服务生命周期枚举 在IocDemo.Container中删除默认的cs文件，新建一个枚举MyServiceLife 用来表示服务的生命周期 1234567891011121314151617namespace IocDemo.Container&#123; /// &lt;summary&gt; /// 服务生命周期枚举 /// &lt;/summary&gt; public enum MyServiceLife &#123; // 瞬时 Transient, // 单例 Singleton, //作用域 Scoped &#125;&#125; 3.MyServiceDescriptor 服务描述类 用于描述注入的服务的生命周期、类型和实现类型，同时用于存放服务实例 123456789101112131415161718192021namespace IocDemo.Container&#123; /// &lt;summary&gt; /// 服务描述类 /// &lt;/summary&gt; public class MyServiceDescriptor &#123; // 服务生命周期 public MyServiceLife Life &#123; get; set; &#125; // 服务类型 public Type ServiceType &#123; get; set; &#125; // 服务实现类类型 public Type ImplementType &#123; get; set; &#125; // 实现实例 public object? ImplementInstance &#123; get; set; &#125; &#125;&#125; 3.3 MyServiceCollection 容器，继承List集合用于存放服务 添加的过程就是根据传入的服务类型和服务实现类等来创建一个服务描述类的实例，并加入到容器集合中 本来是要实现IEnumerable接口，但是这样之后还要实现一些方法，这里为了偷懒，直接继承List 需要编写三个不同生命周期的注册服务方法 由于使用到带有泛型的类的注册时，通过泛型注册的方法就不可用了，所以还需要附带一个根据Type注册的方法，用于适配更多的情况。 注册单例生命周期服务可以在注册的同时直接设置实例，也可以实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119namespace IocDemo.Container&#123; public class MyServiceCollection : List&lt;MyServiceDescriptor&gt; &#123; /// &lt;summary&gt; /// 注册瞬时生命周期服务，使用服务类和服务实现类泛型进行注册 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;TService&quot;&gt;&lt;/typeparam&gt; /// &lt;typeparam name=&quot;TImplement&quot;&gt;&lt;/typeparam&gt; public void AddTransient&lt;TService, TImplement&gt;() where TService : class where TImplement : class &#123; AddTransient(typeof(TService), typeof(TImplement)); &#125; /// &lt;summary&gt; /// 注册瞬时生命周期服务，使用服务类和服务实现类的Type进行注册 /// &lt;/summary&gt; /// &lt;param name=&quot;serviceType&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;implementType&quot;&gt;&lt;/param&gt; public void AddTransient(Type serviceType, Type implementType) &#123; MyServiceDescriptor descriptor = new() &#123; Life = MyServiceLife.Transient, ServiceType = serviceType, ImplementType = implementType &#125;; AddIfNotContent(descriptor); &#125; /// &lt;summary&gt; /// 注册作用域生命周期服务，使用服务类和服务实现类泛型进行注册 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;TService&quot;&gt;&lt;/typeparam&gt; /// &lt;typeparam name=&quot;TImplement&quot;&gt;&lt;/typeparam&gt; public void AddScoped&lt;TService, TImplement&gt;() where TService : class where TImplement : class &#123; AddScoped(typeof(TService), typeof(TImplement)); &#125; /// &lt;summary&gt; /// 注册作用域生命周期服务，使用服务类和服务实现类的Type进行注册 /// &lt;/summary&gt; /// &lt;param name=&quot;serviceType&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;implementType&quot;&gt;&lt;/param&gt; public void AddScoped(Type serviceType, Type implementType) &#123; MyServiceDescriptor descriptor = new() &#123; Life = MyServiceLife.Scoped, ServiceType = serviceType, ImplementType = implementType &#125;; AddIfNotContent(descriptor); &#125; /// &lt;summary&gt; /// 注册单例生命周期服务，使用服务类和服务实现类泛型进行注册 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;TService&quot;&gt;&lt;/typeparam&gt; /// &lt;typeparam name=&quot;TImplement&quot;&gt;&lt;/typeparam&gt; public void AddSingleton&lt;TService, TImplement&gt;() where TService : class where TImplement : class &#123; AddSingleton(typeof(TService), typeof(TImplement), null); &#125; /// &lt;summary&gt; /// 注册单例生命周期服务，使用服务实现类泛型进行注册且直接设置单例 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;TService&quot;&gt;&lt;/typeparam&gt; /// &lt;typeparam name=&quot;TImplement&quot;&gt;&lt;/typeparam&gt; public void AddSingleton&lt;TService&gt;(object instance) where TService : class &#123; AddSingleton(typeof(TService), instance.GetType(), instance); &#125; /// &lt;summary&gt; /// 注册单例生命周期服务，使用服务类和服务实现类的Type进行注册 /// &lt;/summary&gt; /// &lt;param name=&quot;serviceType&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;implementType&quot;&gt;&lt;/param&gt; public void AddSingleton(Type serviceType, Type implementType, Object instance) &#123; var descriptor = new MyServiceDescriptor() &#123; Life = MyServiceLife.Singleton, ServiceType = serviceType, ImplementType = implementType, ImplementInstance = instance &#125;; AddIfNotContent(descriptor); &#125; /// &lt;summary&gt; /// 向MyServiceCollection集合中添加服务描述类实例 /// &lt;/summary&gt; /// &lt;param name=&quot;descriptor&quot;&gt;&lt;/param&gt; private void AddIfNotContent(MyServiceDescriptor descriptor) &#123; if (!this.Any(m =&gt; m.ServiceType == descriptor.ServiceType &amp;&amp; m.ImplementType == descriptor.ImplementType)) &#123; this.Add(descriptor); &#125; &#125; &#125;&#125; 3.4 MyServiceProvider 根节点服务提供类 这里使用线程安全字典存储，模拟高并发的情况，这个字典用于存储容器中注册的服务类型和服务描述类 ResizeService方法用于将容器集合中的服务转移到字典中，用于之后根据Type类型获取服务描述类，即可进一步获取服务。 GetService用于从MyServiceProvider中获取服务，此处暂时不写 123456789101112131415161718192021222324252627282930313233namespace IocDemo.Container&#123; /// &lt;summary&gt; /// 根节点的服务提供者 /// &lt;/summary&gt; public class MyServiceProvider &#123; public ConcurrentDictionary&lt;Type, MyServiceDescriptor&gt; RootDictionary &#123; get; set; &#125; public MyServiceProvider(MyServiceCollection myServices) &#123; RootDictionary = new(); ResizeService(myServices); &#125; /// &lt;summary&gt; /// 将容器中的服务转存到字典 /// &lt;/summary&gt; /// &lt;param name=&quot;myServices&quot;&gt;&lt;/param&gt; private void ResizeService(MyServiceCollection myServices) &#123; foreach (var service in myServices) &#123; RootDictionary.TryAdd(service.ServiceType, service); &#125; &#125; public object? GetService() &#123; return default; &#125; &#125;&#125; 3.5 MyServiceFactory 容器工厂 这里只是对容器工厂简单实现，实际不可能这么简单 这里对MyServiceCollection扩展方法，用于通过容器创建根节点服务提供类实例 12345678910111213141516namespace IocDemo.Container&#123; // 只是简单实现 public static class MyServiceFactory &#123; /// &lt;summary&gt; /// 创建根节点服务提供类实例 /// &lt;/summary&gt; /// &lt;param name=&quot;services&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static MyServiceProvider BuildeProvider(this MyServiceCollection services) &#123; return new MyServiceProvider(services); &#125; &#125;&#125; 3.6 MyServiceProviderScoped 作用域服务提供类 主要是为了针对Scoped作用域生命周期服务类型的获取 因为其生命周期就在于一个请求之内，因此此处不会发生高并发，使用普通的字典即可 字典存放服务类型和服务实例，用于获取单次请求的作用域生命周期服务的实例 这里的字典需要通过根节点服务提供类的字典生成，实际使用中MyServiceProviderScoped会在每一次请求中通过静态的根节点服务提供类创建 而获取服务的GetService就直接调用根节点的同名方法即可，需要传入Type服务类型来获取服务，而MyServiceProviderScoped自身也需要传入，因为需要用来获取Scoped作用域生命周期服务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System.Collections.Concurrent;namespace IocDemo.Container&#123; /// &lt;summary&gt; /// 作用域服务提供类 /// &lt;/summary&gt; public class MyServiceProviderScoped &#123; // 用于存放服务类型和服务实例之间的映射，用于获取作用域单例 public Dictionary&lt;Type, object&gt; ScopedDictionary &#123; get; set; &#125; // 存放根节点服务提供类实例 public MyServiceProvider RootProvider &#123; get; set; &#125; public MyServiceProviderScoped(MyServiceProvider rootProvider) &#123; RootProvider = rootProvider; ScopedDictionary = new(); ResizeService(RootProvider.RootDictionary); &#125; /// &lt;summary&gt; /// 将根节点服务提供类的字典的服务类型和服务描述类转存到作用域服务提供类中，实现单次请求的作用域生命周期 /// &lt;/summary&gt; /// &lt;param name=&quot;rootDictionary&quot;&gt;&lt;/param&gt; private void ResizeService(ConcurrentDictionary&lt;Type, MyServiceDescriptor&gt; rootDictionary) &#123; foreach (var item in rootDictionary) &#123; // 只接收实例，没有实例的服务描述类也一并存入 ScopedDictionary.TryAdd(item.Key, item.Value.ImplementInstance); &#125; &#125; /// &lt;summary&gt; /// 获取服务，直接调用根节点服务提供类的GetService，并把自己传入，仅在获取作用域单例时使用 /// &lt;/summary&gt; /// &lt;param name=&quot;servicetype&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public object? GetService(Type servicetype) &#123; return RootProvider.GetService(servicetype, this); &#125; &#125;&#125; 3.7 MyServiceProvider.GetService方法 首先要在当前的根字典RootDictionary查询要获取的服务类型是否具有服务描述类的值，成功后针对三个不同的生命周期分别操作 ①默认和瞬时生命周期 因为是即用即弃，直接通过服务实现类型反射返回实例 ②单例生命周期 首先查看对应的服务描述类是否有存储实例，没有则也通过反射创建并存储，然后返回 ③作用域生命周期 在作用域服务提供类MyServiceProviderScoped中的字典中查看是否存储了对应的服务实例，没有则反射创建并存到字典中，返回 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677using System.Collections.Concurrent;namespace IocDemo.Container&#123; /// &lt;summary&gt; /// 根节点服务提供类 /// &lt;/summary&gt; public class MyServiceProvider &#123; public ConcurrentDictionary&lt;Type, MyServiceDescriptor&gt; RootDictionary &#123; get; set; &#125; public MyServiceProvider(MyServiceCollection myServices) &#123; RootDictionary = new(); ResizeService(myServices); &#125; /// &lt;summary&gt; /// 将容器中的服务转存到字典 /// &lt;/summary&gt; /// &lt;param name=&quot;myServices&quot;&gt;&lt;/param&gt; private void ResizeService(MyServiceCollection myServices) &#123; foreach (var service in myServices) &#123; RootDictionary.TryAdd(service.ServiceType, service); &#125; &#125; /// &lt;summary&gt; /// 获取服务 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public object? GetService(Type serviecType, MyServiceProviderScoped serviceProviderScoped) &#123; var hasValue = RootDictionary.TryGetValue(serviecType, out MyServiceDescriptor? serviceDescriptor); if(hasValue) &#123; switch (serviceDescriptor!.Life) &#123; // 默认和瞬时生命周期，直接反射返回实例 default: case MyServiceLife.Transient: &#123; return Activator.CreateInstance(serviceDescriptor.ImplementType); &#125; // 单例生命周期，从服务描述类用于存放实例的属性ImplementInstance中拿取，没有则创建并存到属性中 case MyServiceLife.Singleton: &#123; if(serviceDescriptor.ImplementInstance == null) &#123; serviceDescriptor.ImplementInstance = Activator.CreateInstance(serviceDescriptor.ImplementType); &#125; return serviceDescriptor.ImplementInstance; &#125; // 作用域生命周期，从作用域服务提供类实例中的字典中获取，没有则创建并存到字典中 case MyServiceLife.Scoped: &#123; if(serviceProviderScoped.ScopedDictionary.TryGetValue(serviecType, out object? instance)) &#123; if(instance == null) &#123; instance = Activator.CreateInstance(serviceDescriptor.ImplementType); serviceProviderScoped.ScopedDictionary[serviecType] = instance!; &#125; &#125; return instance; &#125; &#125; &#125;else&#123; return null; &#125; &#125; &#125;&#125; 3.8 ServiceFactory增加MyServiceProviderScoped创建 对MyServiceProvider扩展方法，用于通过根节点服务提供类创建MyServiceProviderScoped作用域服务提供类 12345678910111213141516171819202122232425262728namespace IocDemo.Container&#123; /// &lt;summary&gt; /// 容器工厂简单实现 /// &lt;/summary&gt; public static class MyServiceFactory &#123; /// &lt;summary&gt; /// 创建根节点服务提供类实例 /// &lt;/summary&gt; /// &lt;param name=&quot;services&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static MyServiceProvider BuildeProvider(this MyServiceCollection services) &#123; return new MyServiceProvider(services); &#125; /// &lt;summary&gt; /// 通过根节点服务提供类实例创建作用域服务提供类实例创建 /// &lt;/summary&gt; /// &lt;param name=&quot;myServiceProvider&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static MyServiceProviderScoped CreateScoped(this MyServiceProvider myServiceProvider) &#123; return new MyServiceProviderScoped(myServiceProvider); &#125; &#125;&#125; 3.9 WebAPI中测试直接在WeatherForecastController.cs中测试： 首先是创建全局静态容器，模拟框架的创建全局静态容器，这样单例生命周期的服务将一直存储在全局静态容器中的服务描述类里。 然后创建一个静态的根节点服务提供者，模拟框架的静态服务提供类 每次请求中创建一个作用域服务提供类实例，模拟框架的局部作用域服务提供类，用于暂存和获取作用域服务。在一次请求结束后，将会释放。 然后在控制器的构造方法中注册服务并生成服务提供类实例进行模拟 在每次请求时先创建作用域服务提供类实例模拟每次请求的作用域单例存放和获取 最后就是获取服务测试是否成功了 12345678910111213141516171819202122232425262728293031323334namespace IocDemo.Api.Controllers;[ApiController][Route(&quot;[controller]&quot;)]public class WeatherForecastController : ControllerBase&#123; // 创建全局静态容器 static MyServiceCollection services = new(); // 创建静态的根节点服务提供类 static MyServiceProvider provider; public WeatherForecastController() &#123; // 注册服务 services.AddScoped&lt;IUser,User&gt;(); services.AddSingleton&lt;IRole&gt;(new Role()); // 生成服务提供类实例 if(provider == null) &#123; provider = services.BuildProvider(); &#125; &#125; [HttpGet(Name = &quot;GetWeatherForecast&quot;)] public void Get() &#123; // 每次请求,创建作用域服务提供类实例 var providerScoped = provider.CreateScoped(); // 获取服务 var a = providerScoped.GetService(typeof(IUser)); var b = providerScoped.GetService(typeof(IUser)); var c = providerScoped.GetService(typeof(IRole)); &#125;&#125;","tags":["C#"],"categories":["DOTNET"]},{"title":"steam本地联机游戏远程联机探索","path":"/blog/2023-03-15-journal/","content":"steam上的一些游戏只允许本地联机，为此寻找了一些简单远程联机的方法 1.steam远程畅玩steam的远程畅玩在国内无法直接使用，需要加速器的加速。使用过的加速器有： nn加速器：每天看广告可以免费使用 中国移动加速器：一个月5块钱 2.parsecparsec虽然免费而且很多人推荐使用，但是国内移动好像把它墙了，通过更多手段用起来延迟也很高了。 如果直接使用也可能会存在一些其它的问题，可能需要折腾，而这些问题解决方法在b站上有很多 3.腾讯会议腾讯会议的远程控制还行，成功玩过多次游戏，延迟小，而且免费，不过好像只能2个人使用。有时候需要3个人的场景就不行了。 4.闪门一个远控软件，可以多人使用的，但是之前尝试时是2个人，打完一局游戏感觉延迟还行，但是需要付费。 经过我几天后的3人测试后，发现就卡PPT了，不知道是不是因为网络的缘故。也许可以一试 5.RayLink也是一个远控软件，还是免费的，支持多人和手柄。尝试过4人联机延迟低，可能是目前我试过的最好的方案 6.总结最后的总结是，能使用parsec的就优先使用parsec，不能再考虑使用RayLink。如果自己有加速器，可以尝试steam远程畅玩 应该是可以有更好的方法的，其它的也没试过了","tags":["journal"],"categories":["日记"]},{"title":"第二周的结束","path":"/blog/2023-03-13-journal/","content":"第二周的结束，摸鱼 摸鱼这周，摸鱼了很多，周末也没有学很多东西。第二周结束了，下周再努力吧XD","tags":["journal"],"categories":["日记"]},{"title":"C#之反射注入简单练习","path":"/blog/2023-03-12-csharp/","content":"C#之AutoFac 简单练习，使用反射的方式并区分生命周期进行反射依赖注入 反射注入简单练习 首先要安装一个Nuget包：Microsoft.Extensions.DependencyModel 用于获取应用程序及其依赖项的元数据信息，包括程序集名称、版本号、依赖关系等 支持多种格式的依赖项文件，例如项目文件、NuGet包、Assembly文件等 提供了API来查询和操作应用程序的依赖项信息，包括检查程序集是否存在、获取程序集的依赖项列表等 1.获取依赖项 首先获取应用程序的依赖项信息，返回CompilationLibrary集合，其包含了所有被编译进应用程序中的程序集及其依赖项元数据列表 接下来对依赖项集合筛选过滤，返回所有非Serviceable类型且Type为”project”的依赖项。其中，Serviceable表示依赖项是否可服务化，而Type则表示依赖项的类型，”project”表示（自己创建的）项目依赖项，不是来自NuGet等外部源的依赖项 Serviceable：指依赖项是否可被服务化，可服务化程序集一般用于兼容性替代。如果一个程序集被标记为Serviceable，说明它只能被其他程序集引用，而不能被直接加载。 因此，在这里需要排除可服务化的程序集，只加载非服务化的项目程序集。如果不加入该条件，可能获取到不需要的依赖项，那对于去除就会麻烦 以下代码记住就好了 123var libs = DependencyContext.Default .CompileLibraries .Where(x=&gt;!x.Serviceable &amp;&amp; x.Type == &quot;project&quot;).ToList(); 2.获取项目所有程序集的类型 实现通过依赖项的名称制成Assembly AssemblyLoadContext：表示程序集的加载上下文，允许加载和卸载程序集，通过静态属性Default来访问 AssemblyName：表示程序集的完整名称。这里通过使用 lib.Name（当前依赖项的名称）来创建AssemblyName实例，因为方法要用 LoadFromAssemblyName：通过AssemblyName参数加载指定名称的程序集返回Assembly 123456List&lt;Assembly&gt; assemblies = new();foreach (var lib in libs)&#123; assemblies.Add(AssemblyLoadContext.Default .LoadFromAssemblyName(new AssemblyName(lib.Name)));&#125; 3.通过反射程序集的类型注册服务 首先将assemblies程序集中的所有类型注册到Autofac容器中 然后筛选出了所有实现了IocTag接口的非抽象类型（IocTag是自己创建的接口，相当于标签，用于筛选） 将筛选出来的所有类型都注册为自身类型和其实现的所有接口类型 最后是指定注册的服务生命周期为作用域生命周期 1234builder.RegisterAssemblyTypes(assemblies.ToArray()) .Where(t=&gt;t.IsAssignableTo&lt;IocTag&gt;() &amp;&amp; !t.IsAbstract) .AsSelf().AsImplementedInterfaces() .InstancePerLifetimeScope(); 4.区分生命周期的反射注入 为了区分生命周期，将IocTag分为3个生命周期 123456789101112public interface IocTagScope&#123;&#125;public interface IocTagSingleton&#123;&#125;public interface IocTagTransient&#123;&#125; 这里在注册时，就分别对三个生命周期类型进行筛选并注册不同的生命周期类型 并加上了允许属性注入 注册ControllerBase，使用依赖注入框架来管理应用程序中的组件时，也需要将控制器类型注册到容器中 完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System.Reflection;using System.Runtime.Loader;using Autofac;using Microsoft.Extensions.DependencyModel;namespace Demo.Utility;public class DemoUtilityModule : Autofac.Module&#123; protected override void Load(ContainerBuilder builder) &#123; var libs = DependencyContext.Default .CompileLibraries .Where(x=&gt;!x.Serviceable &amp;&amp; x.Type == &quot;project&quot;).ToList(); List&lt;Assembly&gt; assemblies = new(); foreach (var lib in libs) &#123; assemblies.Add(AssemblyLoadContext.Default .LoadFromAssemblyName(new AssemblyName(lib.Name))); &#125; builder.RegisterAssemblyTypes(assemblies.ToArray()) .Where(t =&gt; t.IsAssignableTo&lt;IocTagScope&gt;() &amp;&amp; !t.IsAbstract) .AsSelf().AsImplementedInterfaces() .InstancePerLifetimeScope() .PropertiesAutowired(); builder.RegisterAssemblyTypes(assemblies.ToArray()) .Where(t =&gt; t.IsAssignableTo&lt;IocTagSingleton&gt;() &amp;&amp; !t.IsAbstract) .AsSelf().AsImplementedInterfaces() .SingleInstance() .PropertiesAutowired(); builder.RegisterAssemblyTypes(assemblies.ToArray()) .Where(t =&gt; t.IsAssignableTo&lt;IocTagTransient&gt;() &amp;&amp; !t.IsAbstract) .AsSelf().AsImplementedInterfaces() .PropertiesAutowired(); builder.RegisterAssemblyTypes(assemblies.ToArray()) .Where(t =&gt; t.IsAssignableTo&lt;ControllerBase&gt;() &amp;&amp; !t.IsAbstract) .AsSelf() .PropertiesAutowired(); &#125;&#125; 此时在一个测试项目中注册模块，随便创建几个接口继承三个IocTag并创建实现类去使用，可见注入成功","tags":["C#"],"categories":["DOTNET"]},{"title":"nodejs仿照express封装框架简单练习","path":"/blog/2023-03-11-nodejs-express/","content":"Nodejs简单练习，仿照express封装一个简单的框架 1.0 首先封装web静态服务器 如果请求来的不是favicon.ico，就去找静态资源里的相应文件相应回去给浏览器展示 12345678910111213141516171819202122const fs = require(&#x27;fs&#x27;);const http = require(&#x27;http&#x27;);http.createServer(function (req, res) &#123; //获取地址 let pathname = req.url // 如果访问/就也加载index.html pathname = pathname == &#x27;/&#x27; ? &#x27;/index.html&#x27; : pathname //通过fs模块读取文件 if (pathname == &#x27;/favicon.ico&#x27;) res.end() fs.readFile(&#x27;./static&#x27; + pathname, (err, data) =&gt; &#123; if (err) &#123; //找不到文件错误时，应设置404响应头 res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;这个页面不存在&#x27;) &#125; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125;)&#125;).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;); 此时发现进去网页无法呈现css样式，那么就需要修改。 因为css文件的请求，不能也把响应头设置为text&#x2F;html，而是text&#x2F;css，其它文件如js类似，所以应该根据每一个请求的文件的后缀名去动态设置相应的响应头 首先创建module&#x2F;common.js 12345exports.getMime = function(extname)&#123; extname = extname.slice(1) if (extname == &#x27;&#x27;) extname == &#x27;html&#x27; return &#x27;text/&#x27; + (extname == &#x27;js&#x27; ? &#x27;javascript&#x27; : extname)&#125; app.js中导入自定义模块，动态设置响应头 123456789101112131415161718192021222324252627const fs = require(&#x27;fs&#x27;);const http = require(&#x27;http&#x27;);const path = require(&#x27;path&#x27;);const common = require(&#x27;./module/common.js&#x27;)http.createServer(function (req, res) &#123; //获取地址 let pathname = req.url // 如果访问/就也加载index.html pathname = pathname == &#x27;/&#x27; ? &#x27;/index.html&#x27; : pathname //获取文件后缀名 let extname = path.extname(pathname) //通过fs模块读取文件 if (pathname == &#x27;/favicon.ico&#x27;) res.end() fs.readFile(&#x27;./static&#x27; + pathname, (err, data) =&gt; &#123; if (err) &#123; //找不到文件错误时，应设置404响应头 res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;这个页面不存在&#x27;) &#125; let mime = common.getMime(extname) res.writeHead(200, &#123; &#x27;Content-Type&#x27;: mime + &#x27;;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125;)&#125;).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;); 此时发现json文件请求还是不行，那么继续优化。 检查请求可见，对json文件的请求是这样的：http://127.0.0.1:3000/json/all.json?9498807885421825 那么就需要只获取签名的路径部分，请求参数不应该获取 那么就可以使用url模块解析只取除去请求参数的路径 12345678910111213141516171819202122232425262728const fs = require(&#x27;fs&#x27;);const http = require(&#x27;http&#x27;);const path = require(&#x27;path&#x27;);const url = require(&#x27;url&#x27;);const common = require(&#x27;./module/common.js&#x27;)http.createServer(function (req, res) &#123; //获取地址，用URL对象获取去除请求参数的请求路径 let pathname = url.parse(req.url).pathname // 如果访问/就也加载index.html pathname = pathname == &#x27;/&#x27; ? &#x27;/index.html&#x27; : pathname //获取文件后缀名 let extname = path.extname(pathname) //通过fs模块读取文件 if (pathname == &#x27;/favicon.ico&#x27;) res.end() fs.readFile(&#x27;./static&#x27; + pathname, (err, data) =&gt; &#123; if (err) &#123; //找不到文件错误时，应设置404响应头 res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;这个页面不存在&#x27;) &#125; let mime = common.getMime(extname) res.writeHead(200, &#123; &#x27;Content-Type&#x27;: mime + &#x27;;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125;)&#125;).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;); 但是响应类型还是不够健全，因为很多都不只是单个后缀名就是了，那么就需要优化 通过一个记录了全部后缀类型和请求头对应关系的文件来设置即可（data&#x2F;mime.json） 先读取这个json文件，再转为对象形式，在通过文件后缀名得到请求头对应设置字符 common.js 1234567891011121314151617181920212223const fs = require(&#x27;fs&#x27;);exports.getMime = function (extname) &#123; extname = extname.slice(1) if (extname == &#x27;&#x27;) extname == &#x27;html&#x27; return &#x27;text/&#x27; + (extname == &#x27;js&#x27; ? &#x27;javascript&#x27; : extname)&#125;exports.getFileMime = function (extname) &#123; //异步方法不能直接返回这里得到的值，应要封装为一个promise return new Promise((resolve, reject) =&gt; &#123; fs.readFile(&#x27;./data/mime.json&#x27;, &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) return reject(err) resolve(JSON.parse(data)[extname]) &#125;) &#125;)&#125;//同步方式读取文件（必须等待此执行完毕）exports.getFileMimeSync = function (extname) &#123; let data = fs.readFileSync(&#x27;./data/mime.json&#x27;, &#x27;utf-8&#x27;) return JSON.parse(data)[extname]&#125; app.js 1234567891011121314151617181920212223242526272829303132const fs = require(&#x27;fs&#x27;);const http = require(&#x27;http&#x27;);const path = require(&#x27;path&#x27;);const url = require(&#x27;url&#x27;);const common = require(&#x27;./module/common.js&#x27;)http.createServer(function (req, res) &#123; //获取地址，用URL对象获取去除请求参数的请求路径 let pathname = url.parse(req.url).pathname // 如果访问/就也加载index.html pathname = pathname == &#x27;/&#x27; ? &#x27;/index.html&#x27; : pathname //获取文件后缀名 let extname = path.extname(pathname) //通过fs模块读取文件 if (pathname == &#x27;/favicon.ico&#x27;) res.end() fs.readFile(&#x27;./static&#x27; + pathname, async (err, data) =&gt; &#123; if (err) &#123; //找不到文件错误时，应设置404响应头 res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;这个页面不存在&#x27;) &#125; // 因为是异步的，所以用await和async来搞 let mime = await common.getFileMime(extname) res.writeHead(200, &#123; &#x27;Content-Type&#x27;: mime + &#x27;;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125;)&#125;).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;); 1.1 封装使一行代码创建静态web服务目的：只需传入静态web文件目录，一行代码即可创建服务 首先修改上文的common.js为routes.js，将app.js中用于创建web服务的代码封装 routes.js 12345678910111213141516171819202122232425262728293031323334353637383940414243const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const url = require(&#x27;url&#x27;);//私有方法let getFileMime = function (extname) &#123; //异步方法不能直接返回这里得到的值，应要封装为一个promise return new Promise((resolve, reject) =&gt; &#123; fs.readFile(&#x27;./data/mime.json&#x27;, &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) return reject(err) resolve(JSON.parse(data)[extname]) &#125;) &#125;)&#125;//同步方式读取文件（必须等待此执行完毕）getFileMimeSync = function (extname) &#123; let data = fs.readFileSync(&#x27;./data/mime.json&#x27;, &#x27;utf-8&#x27;) return JSON.parse(data)[extname]&#125;// static创建静态web服务exports.static = function (req, res, staticPath) &#123; //获取地址，用URL对象获取去除请求参数的请求路径 let pathname = url.parse(req.url).pathname // 如果访问/就也加载index.html pathname = pathname == &#x27;/&#x27; ? &#x27;/index.html&#x27; : pathname //获取文件后缀名 let extname = path.extname(pathname) //通过fs模块读取文件 if (pathname == &#x27;/favicon.ico&#x27;) res.end() // 这里动态传入static地址 fs.readFile(&#x27;./&#x27; + staticPath + pathname, async (err, data) =&gt; &#123; if (err) &#123; //找不到文件错误时，应设置404响应头 res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;这个页面不存在&#x27;) &#125; let mime = await getFileMime(extname) res.writeHead(200, &#123; &#x27;Content-Type&#x27;: mime + &#x27;;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125;)&#125; app.js 12345678910const http = require(&#x27;http&#x27;);const routes = require(&#x27;./module/routes.js&#x27;);http.createServer(function (req, res) &#123; // 创建静态web服务 routes.static(req,res,&#x27;./static&#x27;)&#125;).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;); 1.2 构建基础的路由官方解释： 路由（Routing）是由一个URI（或者叫路径）和一个特定的HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问。 通俗的说： 路由指的就是针对不同请求的URL，处理不同的业务逻辑。 案例：将上文项目添加路由配置 首先routes.js中读取文件的操作需要改为同步，否则将访问index.html时还未创建完web服务导致访问变成404 需要确保路由配置和静态资源托管之间不干扰 123456789101112131415161718192021222324252627282930313233343536const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const url = require(&#x27;url&#x27;);//私有方法let getFileMime = function (extname) &#123; var data = fs.readFileSync(&#x27;./data/mime.json&#x27;); //同步方法 let mimeObj = JSON.parse(data.toString()); return mimeObj[extname];&#125;exports.static = function (req, res, staticPath) &#123; //1、获取地址 let pathname = url.parse(req.url).pathname; let extname = path.extname(pathname); if (extname) &#123; //如果有后缀名让静态web处理 否则路由处理 //2、通过fs模块读取文件 if (pathname != &#x27;/favicon.ico&#x27;) &#123; try &#123; let data = fs.readFileSync(&#x27;./&#x27; + staticPath + pathname); if (data) &#123; let mime = getFileMime(extname); res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;&#x27; + mime + &#x27;;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125; &#125; catch (error) &#123; console.log(error) &#125; &#125; &#125;&#125; app.js 12345678910111213141516171819202122232425262728293031323334const http = require(&#x27;http&#x27;);const path = require(&#x27;path&#x27;);const url = require(&#x27;url&#x27;);const routes = require(&#x27;./module/routes&#x27;);http.createServer(function (req, res) &#123; //创建静态web服务，其中读取文件异步改1同步，保证先创建完服务后，再进行路由的配置 // 否则访问index.html时候服务还没创建完，路由匹配到404 routes.static(req, res, &#x27;static&#x27;); //路由 let pathname = url.parse(req.url).pathname; let extname = path.extname(pathname); if (!extname) &#123; //如果有请求地址有后缀名的话让静态web服务去处理 if (pathname == &#x27;/login&#x27;) &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&quot;执行登录&quot;); &#125; else if (pathname == &#x27;/register&#x27;) &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&quot;执行注册&quot;); &#125; else if (pathname == &#x27;/admin&#x27;) &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&quot;处理后的业务逻辑&quot;); &#125; else &#123; res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&quot;404&quot;); &#125; &#125;&#125;).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;); 1.3 使用EJS模板引擎新建一个views文件夹，其中放置一个login.ejs 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;ejs&lt;/h1&gt; &lt;h3&gt; &lt;%=msg%&gt; &lt;br&gt; &lt;ul&gt; &lt;% for(let i=0;i&lt;list.length;i++)&#123;%&gt; &lt;li&gt;&lt;%=list[i].title%&gt;&lt;/li&gt; &lt;%&#125; %&gt; &lt;/ul&gt; &lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; app.js中对&#x2F;login页面渲染时使用ejs 1234567891011121314151617181920212223if (pathname == &#x27;/login&#x27;) &#123; /* res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&quot;执行登录&quot;); */ let msg = &#x27;数据库数据&#x27; let list = [ &#123; title: &#x27;新闻1&#x27; &#125;, &#123; title: &#x27;新闻2&#x27; &#125;, &#123; title: &#x27;新闻3&#x27; &#125;, &#123; title: &#x27;新闻4&#x27; &#125;, ] ejs.renderFile(&#x27;./views/login.ejs&#x27;,&#123;msg,list&#125;,(err, data)=&gt; &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data) &#125; ) &#125; 1.4 原生的get和post使用 获取get传值就是对url解析后的query属性获取，注意url.parse加一个true参数表示解析成对象 而post获取传值则是以文件流的形式的，需要以文件流的方式读取数据 即on监听data事件不断对传来的数据拼接，后面监听end事件即数据接收完毕 form.ejs 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/doLogin&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;br&gt; &lt;br&gt; 密 码: &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;br&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; app.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const http = require(&#x27;http&#x27;);const url = require(&#x27;url&#x27;);const path = require(&#x27;path&#x27;);const ejs = require(&#x27;ejs&#x27;);const routes = require(&#x27;./module/routes&#x27;);const querystring = require(&quot;querystring&quot;); http.createServer(function (req, res) &#123; //创建静态web服务 routes.static(req, res, &#x27;static&#x27;); //路由 let pathname = url.parse(req.url).pathname; //http://127.0.0.1:3000/news?page=2&amp;id=1 //获取请求类型 console.log(req.method); let extname = path.extname(pathname); if (!extname) &#123; //如果有后缀名的话让静态web服务去处理 if (pathname == &#x27;/&#x27;) &#123; //获取get传值 res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;首页&#x27;); &#125; else if (pathname == &#x27;/news&#x27;) &#123; //获取get传值 var query = url.parse(req.url, true).query; console.log(query.page); res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;get传值获取成功&#x27;); &#125; else if (pathname == &#x27;/login&#x27;) &#123; //post演示 ejs.renderFile(&quot;./views/form.ejs&quot;, &#123;&#125;, (err, data) =&gt; &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data) &#125;) &#125; else if (pathname == &#x27;/doLogin&#x27;) &#123; //获取post传值 let postData = &#x27;&#x27;; req.on(&#x27;data&#x27;, (chunk) =&gt; &#123; postData += chunk; &#125;) req.on(&#x27;end&#x27;, () =&gt; &#123; try &#123; postData = JSON.parse(postData) &#125; catch (e) &#123; &#125; req.query = postData // querystring.parse()方法用于将URL查询字符串解析为包含查询URL的键和对值的对象。 console.log(querystring.parse(postData)) &#125;) &#125; else &#123; res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;404&#x27;); &#125; &#125;&#125;).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;); 1.5 模块化方式抽取封装前面app.js中的代码 在routes.js中封装一个对象app，其中分别封装static创建静态web服务，以及上文的几个路由 注意这之后，app.js中需要动态的方式去调用routes.js中封装在对象里的方法：routes[pathname](req, res) routes.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const url = require(&#x27;url&#x27;);const ejs = require(&#x27;ejs&#x27;);//私有方法let getFileMime = function (extname) &#123; var data = fs.readFileSync(&#x27;./data/mime.json&#x27;); //同步方法 let mimeObj = JSON.parse(data.toString()); return mimeObj[extname];&#125;let app = &#123; static: (req, res, staticPath) =&gt; &#123; //1、获取地址 let pathname = url.parse(req.url).pathname; let extname = path.extname(pathname); //2、通过fs模块读取文件 if (pathname != &#x27;/favicon.ico&#x27; &amp;&amp; extname) &#123; try &#123; let data = fs.readFileSync(&#x27;./&#x27; + staticPath + pathname); if (data) &#123; let mime = getFileMime(extname); res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;&#x27; + mime + &#x27;;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125; &#125; catch (error) &#123; &#125; &#125; &#125;, login: (req, res) =&gt; &#123; ejs.renderFile(&#x27;./views/form.ejs&#x27;, &#123;&#125;, (err, data) =&gt; &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data) &#125;) &#125;, news: (req, res) =&gt; &#123; res.end(&#x27;news&#x27;); &#125;, doLogin: (req, res) =&gt; &#123; //获取post传值 let postData = &#x27;&#x27;; req.on(&#x27;data&#x27;, (chunk) =&gt; &#123; postData += chunk; &#125;) req.on(&#x27;end&#x27;, () =&gt; &#123; console.log(postData); res.end(postData); &#125;) &#125;, error: (req, res) =&gt; &#123; res.end(&#x27;404&#x27;); &#125;&#125;// app.login(&#x27;req&#x27;,&#x27;res&#x27;)// app[&#x27;login&#x27;](&#x27;req&#x27;,&#x27;res&#x27;)module.exports = app; app.js 1234567891011121314151617181920212223242526const http = require(&#x27;http&#x27;);const routes = require(&#x27;./module/routes&#x27;);const url = require(&#x27;url&#x27;);const path = require(&#x27;path&#x27;);http.createServer(function (req, res) &#123; //创建静态web服务 routes.static(req, res, &#x27;static&#x27;); //路由 let pathname = url.parse(req.url).pathname.replace(&quot;/&quot;, &quot;&quot;); //http://127.0.0.1:3000/news pathname=news //http://127.0.0.1:3000/login pathname=login // http://127.0.0.1:3000/xxxx pathname=xxxx app.xxxx不存在 let extname = path.extname(pathname); if (!extname) &#123; //如果有后缀名的话让静态web服务去处理 try &#123; routes[pathname](req, res); &#125; catch (error) &#123; routes[&#x27;error&#x27;](req, res); &#125; &#125;&#125;).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;); 1.6 方法扩展&amp;动态注册方法方法扩展 对app赋值一个函数后，还可以对app声明get等等的新方法扩展方法，这样之后原方法还是不会被覆盖，还可以调用 12345678910111213141516171819202122let app=function()&#123; console.log(&#x27;调用app方法&#x27;)&#125;app.get=function()&#123; console.log(&#x27;get方法&#x27;)&#125;app.post=function()&#123; console.log(&#x27;post方法&#x27;)&#125;//调用// app.get();app(); // 打印出 调用app方法/*---------------此时app对象的结构：----------------*/let app: &#123; (): void; get(): void; post(): void;&#125; 动态注册方法 方法中传入一个字符串和一个回调函数，若要注册方法使之在之后可进行调用。 需要先创建一个全局对象G存储动态创建的方法，使用上面 方法扩展 的方式在G对象中进行动态创建G[&#39;/login&#39;](req, res)。 那么app主方法中判断方法存在，然后调用即可（使用[]访问成员方式调用） 1234567891011121314151617181920212223242526272829303132333435363738394041/*最终目标是以这样的方式配置路由：app.get(&quot;/&quot;, function (req, res) &#123; res.send(&#x27;hello world&#x27;)&#125;)*/// global，表示全局let G = &#123;&#125;let app = function (req, res) &#123; console.log(&#x27;调用app方法&#x27;) if (G[&#x27;/login&#x27;]) &#123; // 执行方法 G[&#x27;/login&#x27;](req, res) &#125;&#125;app.get = function (str, cb) &#123; // 注册方法 // G[&#x27;/login&#x27;] = function (param) &#123; &#125; G[str] = cb&#125;app.post = function () &#123; console.log(&#x27;post方法&#x27;)&#125;// 执行方法// 相当于调用后在全局注册了一个方法app.get(&#x27;/login&#x27;, (req, res) =&gt; &#123; // res.send(&#x27;执行login方法&#x27;) console.log(&#x27;执行login方法&#x27;)&#125;)setTimeout(() =&gt; &#123; app(&#x27;req&#x27;,&#x27;res&#x27;)&#125;, 1000); 1.7 仿照express封装app.get()配置路由express中配置路由示例 接下来将按照express的get方法封装配置路由 1234567891011var express = require(&#x27;express&#x27;)var app = express()app.get(&quot;/&quot;, function (req, res) &#123; res.send(&#x27;hello world&#x27;)&#125;)app.get(&quot;/login&quot;, function (req, res) &#123; res.send(&#x27;hello world&#x27;)&#125;)app.post(&quot;/doLogin&quot;, function (req, res) &#123; res.send(&#x27;POST request to the homepage&#x27;)&#125;) route.js route.js中即用动态注册方法的形式对get方法传来的路径字符串和回调函数创建方法 注意createServer后要获取地址pathname，针对对应地址调用对应注册好的方法 还要对不存在页面进行404页面设置 1234567891011121314151617181920212223242526272829const url= require(&quot;url&quot;)// global，表示全局let G = &#123;&#125; //http://127.0.0.1:3000/news //http://127.0.0.1:3000/login //http://127.0.0.1:3000/registerlet app = function (req, res) &#123; // createServer后获取地址，针对对应地址调用对应注册好的方法 let pathname=url.parse(req.url).pathname if (G[pathname]) &#123; // 执行方法 G[pathname](req, res) &#125;else&#123; res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;页面不存在&#x27;); &#125;&#125;app.get = function (str, cb) &#123; // 注册方法 // G[&#x27;/login&#x27;] = function (param) &#123; &#125; G[str] = cb&#125;module.exports = app test.js http.createServer()中直接传入app代表的route.js即可，使得浏览器每次访问地址，都会触发app方法去执行注册好的方法 12345678910111213141516171819202122232425const http = require(&#x27;http&#x27;);const app = require(&#x27;./module/route&#x27;)// 1.注册web服务/* http.createServer(function (request, response) &#123;&#125;).listen(3000); */http.createServer(app).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;);// 2.配置路由app.get(&#x27;/&#x27;,function(req,res)&#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;首页&#x27;);&#125;)app.get(&#x27;/login&#x27;,function(req,res)&#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;执行登录操作&#x27;);&#125;)app.get(&#x27;/news&#x27;,function(req,res)&#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;新闻页面&#x27;);&#125;) 此时就和express的路由配置大致相同了 1.8 配置post方法先对route.js中的逻辑封装到方法中 1234567891011121314151617181920212223242526const url = require(&quot;url&quot;)let server = () =&gt; &#123; let G = &#123;&#125; let app = function (req, res) &#123; // createServer后获取地址，针对对应地址调用对应注册好的方法 let pathname = url.parse(req.url).pathname if (G[pathname]) &#123; // 执行方法 G[pathname](req, res) &#125; else &#123; res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;页面不存在&#x27;); &#125; &#125; app.get = function (str, cb) &#123; // 注册方法 G[str] = cb &#125; return app&#125;module.exports = server() 封装post方法的问题 首先封装的逻辑还是和get一样，传str和cb在G中注册方法，但是这里就需要对G分离成针对get存储和针对post存储了。否则两个同地址不同请求方法的方法将会覆盖 route.js 如下将G分为_get子对象和_post子对象，凡是get的都存储到_get，post同理。 注意后面的逻辑都要改，以及判断是否为页面不存在，需要在_get和_post子对象中判断G[&#39;_&#39;+method][pathname]是否创建了对应地址的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const url = require(&quot;url&quot;)let server = () =&gt; &#123; let G = &#123;&#125; // 把get和post分开 /* let G1 = &#123;&#125; let G2 = &#123;&#125; */ G._get = &#123;&#125; G._post = &#123;&#125; let app = function (req, res) &#123; // createServer后获取地址，针对对应地址调用对应注册好的方法 let pathname = url.parse(req.url).pathname // 获取请求类型用于分开注册get和post方法 let method = req.method.toLowerCase() if (G[&#x27;_&#x27;+method][pathname]) &#123; // 注意G分为_get和_post后这里也要改 // 执行方法 if (method == &#x27;get&#x27;) &#123; // get G._get[pathname](req, res) &#125; else &#123; // post // 对于post，还需要获取到post的数据，挂载到req.body上 let postData = &#x27;&#x27; req.on(&#x27;data&#x27;,(chunk)=&gt; &#123; postData+=chunk &#125;) req.on(&#x27;end&#x27;,()=&gt; &#123; req.body = postData //扩展req对象属性进行挂载 G._post[pathname](req, res) &#125;) &#125; &#125; else &#123; res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;页面不存在&#x27;); &#125; &#125; //注意这里要把get和post方法注册分开，否则同地址，后面比如post注册的方法会覆盖前面get的 app.get = function (str, cb) &#123; // 注册方法 G._get[str] = cb &#125; app.post = function (str, cb) &#123; // 注册方法 G._post[str] = cb &#125; return app&#125;module.exports = server() test.js 123456789101112131415161718192021222324252627282930313233const http = require(&#x27;http&#x27;);const app = require(&#x27;./module/route&#x27;)const ejs = require(&#x27;ejs&#x27;)// 1.注册web服务/* http.createServer(function (request, response) &#123;&#125;).listen(3000); */http.createServer(app).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;);// 2.配置路由app.get(&#x27;/&#x27;,function(req,res)&#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;首页&#x27;);&#125;)app.get(&#x27;/login&#x27;,function(req,res)&#123; // res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); // res.end(&#x27;执行登录操作&#x27;); ejs.renderFile(&#x27;./views/form.ejs&#x27;,&#123;&#125;,(err,data)=&gt; &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125;)&#125;)app.post(&#x27;/doLogin&#x27;,function(req,res)&#123; console.log(req.body) res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(req.body);&#125;) 测试可见，在访问&#x2F;login后，填写账号密码可显示在浏览器上 同时测试get和post的路径相同，但不会报错 1.9 封装res.send()方法 首先写一个用于扩展res.send()方法的方法，然后后面createServer开始时马上调用对res挂载send方法 1234567891011121314151617181920212223function changeRes(res) &#123; // 为res扩展一个send方法 res.send = (data) =&gt; &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125;&#125;let server = () =&gt; &#123; let G = &#123;&#125; // 把get和post分开 /* let G1 = &#123;&#125; let G2 = &#123;&#125; */ G._get = &#123;&#125; G._post = &#123;&#125; let app = function (req, res) &#123; // createServer时，对res扩展send方法 changeRes(res) // createServer后获取地址，针对对应地址调用对应注册好的方法 let pathname = url.parse(req.url).pathname ...&#125; 1.10 封装静态web服务 创建static目录，下创建css&#x2F;style.css写入样式，启动代码后浏览器调试工具可见style.css传输失败 那么把之前的创建静态web服务相关的文件data和代码复制 G中扩展一个staticPath用于存储静态web服务的文件路径 同时也是在createServer后马上去执行创建静态web服务的逻辑 app扩展一个static方法用于重新设置staticPath路径 route.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const url = require(&#x27;url&#x27;);//扩展resfunction changeRes(res) &#123; res.send = (data) =&gt; &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125;&#125;//根据后缀名获取文件类型function getFileMime(extname) &#123; var data = fs.readFileSync(&#x27;./data/mime.json&#x27;); // 这里还有硬编码的小问题不管了 let mimeObj = JSON.parse(data.toString()); return mimeObj[extname];&#125;//静态web服务的方法function initStatic(req, res, staticPath) &#123; //1、获取地址 let pathname = url.parse(req.url).pathname; // pathname = pathname == &#x27;/&#x27; ? &#x27;/index.html&#x27; : pathname; let extname = path.extname(pathname); //2、通过fs模块读取文件 if (extname) &#123; //如果有后缀名用静态web服务处理 try &#123; let data = fs.readFileSync(&#x27;./&#x27; + staticPath + pathname); if (data) &#123; let mime = getFileMime(extname); res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;&#x27; + mime + &#x27;;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125; &#125; catch (error) &#123; console.log(error); &#125; &#125;&#125;let server = () =&gt; &#123; let G = &#123; _get: &#123;&#125;, _post: &#123;&#125;, // G中声明staitcPath（静态web目录） staticPath: &#x27;static&#x27; &#125; // 把get和post分开 /* let G1 = &#123;&#125; let G2 = &#123;&#125; */ let app = function (req, res) &#123; //扩展res的方法 changeRes(res); //配置静态web服务 initStatic(req, res, G.staticPath); let pathname = url.parse(req.url).pathname; //获取请求类型 let method = req.method.toLowerCase(); console.log(method); let extname = path.extname(pathname); if (!extname) &#123; //如果有后缀名用静态web处理 if (G[&#x27;_&#x27; + method][pathname]) &#123; if (method == &quot;get&quot;) &#123; G[&#x27;_&#x27; + method][pathname](req, res); //执行方法 &#125; else &#123; //post 获取post的数据 把它绑定到req.body let postData = &#x27;&#x27;; req.on(&#x27;data&#x27;, (chunk) =&gt; &#123; postData += chunk; &#125;) req.on(&#x27;end&#x27;, () =&gt; &#123; req.body = postData; G[&#x27;_&#x27; + method][pathname](req, res); //执行方法 &#125;) &#125; &#125; else &#123; res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;页面不存在&#x27;); &#125; &#125; &#125; //注意这里要把get和post方法注册分开，否则同地址，后面比如post注册的方法会覆盖前面get的 app.get = function (str, cb) &#123; // 注册方法 G._get[str] = cb &#125; app.post = function (str, cb) &#123; // 注册方法 G._post[str] = cb &#125; // 配置静态web服务路径 app.static = (staticPath) =&gt; &#123; G.staticPath = staticPath &#125; return app&#125;module.exports = server() app.js 1234567891011121314151617181920212223242526272829303132const http = require(&#x27;http&#x27;);const app = require(&#x27;./module/route&#x27;)const ejs = require(&#x27;ejs&#x27;)// 1.注册web服务/* http.createServer(function (request, response) &#123;&#125;).listen(3000); */http.createServer(app).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;);//一行代码配置静态web服务app.static(&#x27;static&#x27;)// 2.配置路由app.get(&#x27;/&#x27;,function(req,res)&#123; res.send(&#x27;首页&#x27;)&#125;)app.get(&#x27;/login&#x27;,function(req,res)&#123; // res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); // res.end(&#x27;执行登录操作&#x27;); ejs.renderFile(&#x27;./views/form.ejs&#x27;,&#123;&#125;,(err,data)=&gt; &#123; res.send(data) &#125;)&#125;)app.post(&#x27;/doLogin&#x27;,function(req,res)&#123; console.log(req.body) res.send(req.body)&#125;) 至此，封装一个类似express框架的小项目完成","tags":["Nodejs"],"categories":["Nodejs"]},{"title":"博客应该写什么","path":"/blog/2023-03-10-journal/","content":"今天看到了一篇文章，讲述了博客应该要写什么 博客应该写什么呢原文地址：What to blog about 这篇文章中说到了如果没有东西写，可以想一下今天学到了什么和正在做的项目。而且我觉得也完全不用勉强自己写很多字数，只需要一个行动即可。 每天学到的东西也不多，可能不足以为了这点东西来写一个博客，或者是学的东西太简单了，属于是网上一搜一大把的那种，写的可能还更好。但是写一下自己的某些思考应该还是不错的，一天之内随便思考点什么东西，然后随便写点什么东西差不多。或者说，其实也不用强迫每天都写，一个星期内有点产出差不多了。 总之还是加油吧。 别的东西这学期又有好多麻烦的项目和任务。为什么说麻烦，因为感觉自己的技术还只是学了点皮毛的程度，身边好多大佬对于这种项目想必是信手拈来吧。正因为如此，还是要不断的学习和写代码才行。","tags":["journal"],"categories":["日记"]},{"title":"PowerShell7的安装和简单使用","path":"/blog/2023-03-09-install-powershell/","content":"针对PowerShell7的简单安装和配置 1.PowerShell简介 PowerShell全称 Windows Power Shell，是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以利用.NET Framework的强大功能来执行一些操作 之前使用WSL时针对Windows Terminal集成的默认的PowerShell进行了配置，默认的PowerShell也叫 Windows PowerShell 5.1 ，是在 .NET Framework v4.5 基础上构建的 但是现在的 PowerShell 7.x 也称为 Powershell Core，打开默认的PowerShell会打印微软的推荐： 尝试新的跨平台 PowerShell https://aka.ms/pscore6 听名字就知道它是基于跨平台且开源的.NET Core 构建的。因为跨平台，当然也可以在Linux上使用 2.安装PowerShell7现在最新的PowerShell7.3基于2022年11月8日发布的**.NET 7**，当然也可以选择下载LTS版本等 安装步骤 直接去github下载并安装release：PowerShell&#x2F;PowerShell: PowerShell for every system! (github.com) 安装界面的功能都可勾上 安装完成后，Windows Terminal就会自动集成PowerShell7，有了PowerShell7，Windows Terminal就可以选择使用PowerShell7为默认启动配置了 3.PowerShell的配置3.1 NF字体 首先还是需要有一个NF字体，因为默认字体不支持之后要配置的部分主题格式 若之前使用Windows Terminal时已经安装了NF字体就不需要下载了，以下网站中随便选一个字体下载安装： https://www.nerdfonts.com 然后使用管理员身份打开Windows Terminal，Ctrl+ shift+, 打开wt的settings.json 对其中的 profiles.defaults下 添加以下字体配置，face设置的就是刚刚下载的字体名，最后保存即可 1234567&quot;profiles&quot;: &#123; &quot;defaults&quot;: &#123; &quot;font&quot;: &#123; &quot;face&quot;: &quot;下载的字体名&quot; 3.2 安装Oh My Posh 和主题配置 Oh My Posh的已经不再支持PowerShell模块，因此不能再使用以下的方式安装 Install-Module oh-my-posh -Scope CurrentUser -SkipPublisherCheck 如果之前是这样安装的，需要参考Oh My Posh的迁移方案：https://ohmyposh.dev/docs/migrating 记得要删除之前的模块：Uninstall-Module oh-my-posh -AllVersions 以下使用winget方式安装 1winget install oh-my-posh 然后输入notepad $PROFILE打开PowerShell的配置文件，添加如下命令。重启后即可成功配置Oh My Posh 可在Oh My Posh的官方文档中选择主题：https://ohmyposh.dev/docs/themes 更换主题只需修改xxxx.omp.json即可 退出后重新进入，可见配置生效 1oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\\jandedobbeleer.omp.json&quot; | Invoke-Expression 3.3 模块安装 首先安装PSReadLine，用于命令自动提示 1Install-Module -Name PSReadLine -AllowPrerelease -Scope CurrentUser -Force -SkipPublisherCheck 然后安装文件图标库，显示文件时可显示文件的颜色以及图标 1Install-Module -Name Terminal-Icons -Repository PSGallery 接下来就要在PowerShell的启动前参数中配置 12345oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\\jandedobbeleer.omp.json&quot; | Invoke-Expression# 导入文件图标模块Import-Module -Name Terminal-Icons# 命令行提示Tab选择功能Set-PSReadlineKeyHandler -Key Tab -Function MenuComplete 此时即配置完成 如果觉得打开速度慢，可以不导入文件图标模块","tags":["PowerShell"],"categories":["PowerShell"]},{"title":"整理书签","path":"/blog/2023-03-07-journal/","content":"对于整理书签的思考 整理书签浏览器书签断断续续存了太多了，以前的存放方式感觉不太行，所以要整理，然而整理就要花费很多时间了。 原因可能是一开始没有做好书签的存放位置和层次，以及平时保存的一些文章类型的书签没有及时去看，就开始堆积了。 这个问题在b站视频的收藏中也存在，很多人说“收藏从未停止，学习从未开始”，一个视频觉得不错就把它收藏了但是没有去看，那就和没有收藏没啥区别。以前也是收藏了很多的b站视频，后来意识到了这个问题。 现在的做法就是遇到一个好的视频，但是当前没有时间去看，就可以直接添加到稍后观看里去，这样就会经常想起来去看完这个视频，所以现在收藏视频变得越来越少了。 不过还是难免会遇到稍后观看也吃灰的问题。这个问题的可能还是跟拖延症有关，这个习惯真的不好，很多应该要做的事没有及时完成，然后导致后续要做的事又完成不了，最后可能会发生灾难。要想改正也只能看自己了。整理书签也不能马上整理完，需要每天持续一点点地整理。 有一个插件或许有点作用，这个插件能间隔一段时间随机找一个书签然后提示出来对它进行处理。可能对整理书签有些帮助 温故知新 - Microsoft Edge Addons","tags":["journal"],"categories":["日记"]},{"title":"时间消耗","path":"/blog/2023-03-06-journal/","content":"对于时间的消耗的思考 时间消耗这个周末，说实话，摆烂了好多，又在折腾各种乱七八糟的东西，时间花费了很多。折腾东西也许是挺有意思的，但可能是有一个什么曲线在，如果后面一直没法解决问题，就会感觉无聊想放弃了。唉自己解决问题的速度还是太慢了，也是太菜的原因吧，还是得更多的学习才行。 对于学校课程，应该减少摆烂，感觉平时有点浪费时间。有时候一小段时间觉得反正就那么点时间，于是就摆了。有些人就能充分利用好碎片时间，这得学习下。 晚上熬夜的事，只能说可能是因为事情太多，或者当时恰好什么事没做完，就开始熬了。熬夜确实不太好，希望以后能早点睡觉吧。","tags":["journal"],"categories":["日记"]},{"title":"WSL2的安装和简单使用","path":"/blog/2023-03-05-wsl2-install-use/","content":"基于b站和各个网上教程的WSL安装使用简单记录 1.安装WSL1.1 前置条件和说明 可直接查阅微软官方文档： 首先要确保电脑的CPU开启了虚拟化 同时需要win10版本为 1903 或更高版本，内部版本为 18362 或更高版本 WSL2可直接安装预览版，也可手动安装旧版 安装 WSL | Microsoft Learn 旧版 WSL 的手动安装步骤 | Microsoft Learn 1.2 安装步骤和查看旧版手动安装步骤 ①打开powershell， 启用“适用于 Linux 的 Windows 子系统”可选功能，同时 启用“虚拟机平台”可选功能，然后重启电脑 12dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestartdism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart ②下载并安装 Linux 内核更新包： WSL2 Linux Kernel update package for x64 machines 将 WSL 2 设置为默认版本 1wsl --set-default-version 2 安装Linux发行版，并进行配置 直接在Microsoft Store中搜索WSL即可找到几个Linux发行版，此处安装的是ubuntu20.04，直接点击安装即可。 打开刚刚安装的ubuntu，因为是第一次安装，会需要进行一些初始设置，如需要输入用户名和密码 至此即安装完成，可以直接点击ubuntu图标进行使用 查看安装完成后的系统 输入screenfetch即可查看到Linux版本 同时这个ubuntu已经预装了git和python等等，均可查看 在powershell中，通过命令：wsl -l -v，可以查看子系统的运行状态。 新版安装方法：只需wsl --install后重启电脑，之后即可直接安装Linux发行版 2.使用Windows Terminal2.1 Windows Terminal安装 Windows Terminal是一个比较好用的终端工具，可以集成powershell、cmd、wsl等 在Microsoft Store中直接搜索Windows Terminal，即可下载安装 可见可直接在其中打开wsl 2.2 Windows Terminal的美化 首先直接在Microsoft Store搜索 on-my-posh下载并安装 设置字体 下载一个Nerd Font字体并安装：https://www.nerdfonts.com 然后使用管理员身份打开Windows Terminal，Ctrl+ shift+, 打开wt的settings.json 对其中的 profiles.defaults下 添加以下字体配置，face设置的就是刚刚下载的字体名，最后保存 1234567&quot;profiles&quot;: &#123; &quot;defaults&quot;: &#123; &quot;font&quot;: &#123; &quot;face&quot;: &quot;下载的字体名&quot; 配置主题 直接中wt中输入以下命令打开powershell配置文件 如果找不到配置文件，直接按照$PROFILE输出的路径和文件名，新建一个即可。 一般powershell的配置文件在用户的文档目录下的\\WindowsPowerShell文件夹下 1notepad $PROFILE 在打开的文件中写入以下代码，然后保存退出 1oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\\json.omp.json&quot; | Invoke-Expression 然后wt中输入下面的命令，使配置生效。至此主题配置完成 1.$PROFILE 当然也可以修改主题，通过以下命令可找到各种主题，复制想要更换的主题名，重新打开powershell配置文件修改xxx.omp.json，xxx就是新的主题名，然后保存退出重复上一个步骤并重启即可 1Get-PoshThemes 3.为WSL配置zsh相比于默认的 Bash，zsh 有更多的自定义选项；然后oh-my-zsh是一个流行的 zsh 配置，可以自动配置zsh 首先安装zsh 1sudo apt install zsh 安装ohmyzsh，根据提示安装即可 1sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 如果无法访问到github，可进行如下操作： 在 https://site.ip138.com/raw.Githubusercontent.com/输入raw.githubusercontent.com查询IP地址 然后使用code /etc/hosts 修改hosts，添加刚刚的ip映射 使用ls -la可见zsh的配置文件.zshrc，可对zsh配置插件和主题，可查看ohmyzsh的wiki进行配置 比如以下安装一个ash-autosuggestions，cd进入.oh-my-zsh的plugin文件夹直接git clone对应的仓库即可 然后对 .zshrc修改，增加插件的名称即可 1234plugins=( git zsh-autosuggestions) 这个插件可以根据历史记录和完成提示键入的命令 实现效果： 4.使用VSCode配合WSL编写代码 打开vscode后，可见其自动提示安装WSL相关插件，直接安装：Remote Development 在wt的wsl中创建一个目录，然后cd进入此目录 12mkdir WSLCodeDemocd WSLCodeDemo 此时使用以下命令试图通过vscode打开目录，可见其会自动安装 VS Code Server。接下来vscode就成功打开此目录了 同时安装插件后，可在远程资源管理器中直接打开WSL的文件目录，可以直接下载和上传文件 1code . 此时，在vscode中新建文件，就是在WSL中新建文件。即此时可在windows中通过vscode编辑和处理WSL内部的文件了。因为WSL默认安装了Python3，以下模拟编写Python 此时新建一个test.py，vscode会提示安装python插件，并在WSL上启用插件。此时写入简单程序 注意这里运行的vscode的插件分为本地和远程插件，可以在WSL上安装插件 1print(&#x27;Hello world!&#x27;) 然后vscode中直接运行程序，可见在wsl中成功输出了Hello world! 此时，就实现了在Windows中编写代码，而在Linux中直接运行的效果 5.文件的互相访问5.1 Windows访问WSL中的文件①使用vscode访问WSL中的文件 还是使用code命令，比如在WSL的根目录中输入命令，即可在vscode中查看到WSL根目录下的所有文件 同时vscode的远程资源管理器也可打开并访问文件 1code . ②使用Windows的资源管理器 可直接在我的电脑中查看并打开WSL的文件目录进行访问 同时也可以直接在WSL中输入命令使用资源管理器打开当前的目录 1explorer.exe . ③使用SSH连接 这和Linux中安装ssh服务，然后进行连接类似了 5.2 WSL访问Windows的文件 在WSL根目录下有一个mnt目录，进入此处可看到windows的每个盘了 123cd /mnt/ccd /mnt/dcd /mnt/e 此时可见windows中的文件，可用命令进行操作 6.WSLg 全称Windows Subsystem for Linux GUI WSLg是图形化的WSL，能够完成Ubuntu一小部分的图形显示，即可以运行WSL中的GUI程序，比如gedit WSLg本来只在win11上支持，但是win10的22H2版本也支持WSLg 如下打开gedit： 安装步骤 如果Windows版本是win11，或者是win10 22H2版本，才可以使用。win10低版本首先需要更新系统升级到22H2 然后更新WSL 1wsl --update 更新完成后检查WSL的版本，能够正常显示，说明安装成功 1wsl --version 显示结果： WSL 版本： 1.1.3.0 内核版本： 5.15.90.1 WSLg 版本： 1.0.49 那么此时就可以愉快地使用WSLg了 比如安装gedit并使用gedit命令使用，安装后同时也可直接在windows开始目录下找到安装在WSL中的程序，点击也可直接运行 123sudo apt install gedit -ygedit 总的来说，有了WSLg后，WSL就更好用了，用起来的感觉挺神奇","tags":["vscode","Linux"],"categories":["Linux"]},{"title":"使用vscode编写C#代码","path":"/blog/2023-03-03-csharp-with-vscode/","content":"针对vscode如何编写C#代码进行了简单配置 1.环境准备 在cmd或powershell中输入以下命令可查看电脑是否安装了.NET的相关SDK，以及查看版本 1dotnet --info 目前最新.NET版本是7 如果没有，则去微软官网进行下载并安装：下载 .NET(Linux、macOS 和 Windows) (microsoft.com) 安装步骤是无脑下一步 此时再输入上述命令，成功查看到.NET版本，即安装成功 2.vscode插件安装1、C# 装这个就能做大部分事了 2、vscode-solution-explorer 可自动生成解决方案和项目，不用输命令 3、C# XML Documentation 用于&#x2F;&#x2F;&#x2F;自动生成文档注释 4、.NET Core Add Reference 用于在项目上直接右键添加引用 5、Add Local .Net Reference 用于添加本地程序集引用 6、ASP.NET Core Switcher MVC项目时，可直接在视图和控制器之间切换 7、C# Extensions 用于右键自动添加C#类、接口、MVCController等 以上插件基本够用了，别的之后按需获取即可 3.创建一个项目 首先在Solution Explorer中选择Create New Solution，然后输入FirstDemo。可见创建了sln解决方案文件 然后在Solution Explorer中对解决方案右键——Add New Project，即可为当前解决方案添加项目 这里选择控制台应用程序，语言选择C#，然后对项目的命名，可以和解决方案同名，回车即可创建成功 打开项目下的Program.cs文件，vscode右下角会弹出创建launch和tasks文件的选项，点击yes即可。如果不创建将无法调试 此时生成的Program.cs如下，这是C#使用了顶级语句 12// See https://aka.ms/new-console-template for more informationConsole.WriteLine(&quot;Hello, World!&quot;); 不用顶级语句将会创建如下 123456789101112using System;namespace FirstDemo // Note: actual namespace depends on the project name.&#123; internal class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;Hello World!&quot;); &#125; &#125;&#125; 点击调试，即可成功运行输出“Hello World!”，说明成功","tags":["C#","vscode"],"categories":["DOTNET"]},{"title":"C#基础语法速成","path":"/blog/2023-03-02-csharp-basic-grammar/","content":"这学期突然要学C#，那就学吧。以下笔记仅作自用 1.C#基本认识和特点 C#是微软公司发布的一种面向对象的、运行于 .NET Framework 和 .NET Core (完全开源，跨平台）之上的高级程序设计语言。 C#是一种安全的、稳定的、简单的、优雅的，由C和C++衍生出来的面向对象的编程语言。它在继承C和C++强大功能的同时去掉了一些它们的复杂特性。 C#是面向对象的编程语言。 C#可以用指针，但是不推荐也少用了 .NET和C#关系 .NET是C#运行环境，C#是开发语言， C# 可以编写在.NET 中运行的应用程序。 .NET公共语言运行时 (CLR) 是生成所有.NET 应用的基础，这个运行时还支持多种语言，有 C#、F# 和 Visual Basic 语言，但是C#算是主角 2.Visual Studio的安装和使用 Microsoft Visual Studio（简称VS)是美国微软公司的开发工具包系列产品VS是一个基本完整的开发工具集，是编写C＃程序或者说NET程序最常用的开发工具。 下载vs网址：https://visualstudio.microsoft.com/zh-hans/downloads/ vsi工作负载，根据自己的情况选择需要的安装模块，一般选择：ASP.NET和Web开发、.NET桌面开发、通用Windows平台开发、数据库存储和处理、Visual Studio扩展开发、.NET Core跨平台开发 2.1 开始第一个项目 就不创建控制台程序了，直接创建一个windows窗体应用，就不搞控制台应用了 选择C#、Windows、桌面，找到 WPF 应用(.NET Framwork) 2.2 VS的结构 一般习惯工具箱和解决方案资源管理器放在左边 别的好像也没啥了，随意了 3.cs文件结构 上面程序的各个部分： using System： using 关键字：用于在程序中包含System命名空间。一个程序一般有多个using语句。 namespace声明：一个namespace是一系列的类。WebApplication1命名空间 包含了类Program。 class声明：类Program包含了程序使用的数据和方法声明。类一般包含多个方法，方法定义了类的行为。类只有一个Main方法。 Main方法：是所有C#程序的入口点。Main方法说明当执行时类将做什么动作。 Main方法通过方法体中的语句指定它的行为。 以下几点值得注意： 一个cs文件的结构大约是由以上几个部分组成，但是根据不同的需求和作用，会有不同的内容 程序的执行从Main方法开始 4.C#基本语法 C#是一种面向对象的编程语言。在面向对象的程序设计方法中，程序由各种对象组成。相同种类的对象通常具有相同的类型。 C#是大小写敏感的 所有的语句和表达式必须以分号 ; 结尾 与Java不同的是，文件名可以不同于类的名称 4.1 关键字关键字，是对编译器有特殊意义的预定义保留标示符，它们不能在程序中用作标示符 using关键字 using关键字用于在程序中包含命名空间。一个程序可以包含多个using语句。 在任何C＃程序中的第一条语句都是： 1using System; class关键字 class关键字用于声明一个类。 4.2 注释 块注释 123/*这个程序演示C#语言的多行注释语法*/ 单行注释是用//符号表示。 1// test 文档注释用///符号表示 应用场合：声明的方法、类上 123456/// &lt;summary&gt;/// 这是主程序入口/// &lt;/summary&gt;/// &lt;param name=&quot;args&quot;&gt;需要传入的参数&lt;/param&gt;public static void Main(string[] args)&#123;&#125; 注释的作用： 解释：说明代码作用 注销：将暂时不需要的代码注销 总结： 不写注释是流氓 名字瞎起是扯淡 相比注销，注释意义更大 要做到别人一看就能看懂 4.3 变量 在C#中，每个变量都有一个特定的类型，不同类型的变量其内存大小也不尽相同。 C#的基本类型： 类型 举例 整数类型 byte(0-255)、short(-32768-32767)、int(-2*10^9-2*10^9)、long 浮点型 float、double 十进制类型 decimal 布尔类型 bool 字符类型 string、char 空类型 null float浮点类型，小数后需带f&#x2F;F decimal相当于精度更大的浮点型，但会有更多的性能损耗 浮点型之间的转换只有float转换为double一种，decimal无法直接转换到浮点型 5.C#语法进阶5.1 表达式 表达式由操作数(operand)和运算符(operator)构成。运算符的示例包括 ＋、- 、*、／ 和 new。操作数的示例包括文本、字段、局部变量和表达式。 当表达式包含多个运算符时，运算符的优先级(precedence)控制各运算符的计算顺序。例如，表达式x+yz按x + (y z)计算，因为＊运算符的优先级高于＋运算符。 （了解）大多数运算符都可以重载(overload,)。运算符重载允许指定用户定义的运算符实现来执行运算这些运算的操作数中至少有一个，甚至所有操作数都属于用户定义的类类型或结构类型。 下表总结了C#简单常用的运算符，并按优先级从高到低的顺序列出各运算符类别。同一类别中的 运算符优先级相同。 类别 表达式 说明 基本 x.m 成员访问 x(…) 方法和委托调用 x[…] 数组和索引器访问 new T(…) 对象和委托创建 new T(…){…} 使用初始值设定项创建对象 new {…} 匿名对象初始值设定项 new T[…] 数组创建 类别 表达式 说明 一元 +x 恒等 -x 求相反数 !x 逻辑求反 ~x 按位求反 ++x 前增量 –x 前减量 x++ 后增量 x– 后减量 (T)x 将x显式转换为类型T 类别 表达式 说明 二元 x*y、x&#x2F;y、x%y、x+y、x-y 乘除余加减（加号还有字符串串联） x&lt;&lt;y、x&gt;&gt;y 位左移、位右移 x&lt;y、x&gt;y、x&lt;&#x3D;y、x&gt;&#x3D;y 小于、大于、小于等于、大于等于 x is T 如果x为类型T，则返回 true，否则返回false x as T 返回转换为类型T的x，如果x不是T则返回null x&#x3D;&#x3D;y、x!&#x3D;y 等于、不等于 x&amp;y、x|y 整型按位AND&#x2F;OR，布尔逻辑AND&#x2F;OR x &amp;&amp; y 仅当x为true时，才对y求值 x ?? y 如果x为null，则计算结果为y，否则计算结果为x 类别 表达式 说明 三元 x?y:z 如果x为true，则对y求值；反之对z求值 x&#x3D;y 赋值 x&#x3D;x+y 复合赋值 (T x)&#x3D;&gt;y 匿名函数（lambda表达式） 5.2 分支语句if语句 1234567if(i&gt;1)&#123;&#125;else if(i&gt;2)&#123; &#125;else&#123; &#125; switch语句 12345678switch (i) &#123; case 1: Console.WriteLine(&#x27;1&#x27;); break; default: Console.WriteLine(&#x27;2&#x27;); break;&#125; for循环 123for (int k = 0; k &lt; 10; k++) &#123; Console.WriteLine(k);&#125; while循环 123456789int i3 = 0;while (true) &#123; i3++; if (i3 == 3) break;&#125;do &#123; Console.WriteLine(&#x27;1&#x27;);&#125; while (true); 这些看看就好了 5.3 数组 数组是一组相同类型的数据。 数组中的数据需要通过数字索引来访问。 数组的声明 数组的声明需要使用new关键字。 在声明数组时，可以使用｛｝来初始化数组中的元素。 如果在数组声明之初没有使用大括号来初始化数组中的元素，则需要指定数组的大小。 在声明初始化有元素的数组时，也可以指定数组大小。 12345678// 声明没有元素的数组int[] arr1 = new int[6];// 声明初始化有元素的数组int[] arr2 = new int[6] &#123; 1, 2, 3, 4, 5, 6 &#125;;// 在声明初始化有元素的数组时，也可以指定数组大小string[] strings = new string[3] &#123; &quot;1&quot;, &quot;2&quot;, &quot;3&quot; &#125;;// 不指定大小声明数组int[] arr3 = &#123; 1, 2, 3 &#125;; 通过索引获取数组中的元素 给数组指定长度时，数组准备存放多少元素，长度就设置为多少 用索引获取数组内的元素时，索引从0开始获取。 所以数组中最大的索引数字，比指定数组长度小1。 这些看看就好了 5.4 类型转换 (int)表示使用显式强制转换，是一种类型转换，C#默认整型是int32，因此使用此方法转成int32位，不遵循四舍五入，于是只截取到了整数部分 (int)5.21 &#x2F;&#x2F;输出5 ①int.Parse()：只支持将string类型转成int，Parse就是把String类型转换成int、char、double等 也就是*.Parse(string)括号中的一定要是string类型。 1234String st = &quot;5.21&quot;;double n = 5.21;int.Parse(st); //输出5int.Parse(n); //报错 ②Convert.Tolnt32(double value)：不完全遵循四舍五入，如果value为两个整数中间的数字，则返回二者中的偶数 注意： Convert.Tolnt32() 和 int.Parset() 对于空值(null)的处理不同，Convert.Tolnt32(nul)会返回0而不会产生任何异常，但int.Parse(null)则会产生异常 123456Console.WriteLine(Convert.ToInt32(4.3));//四舍五入，输出4Console.WriteLine(Convert.ToInt32(4.5));//第一位小数为5时，4.5在4和5之间，输出偶数4Console.WriteLine(Convert.ToInt32(4.53));//四舍五入，输出5Console.WriteLine(Convert.ToInt32(5.3));//四舍五入，输出5Console.WriteLine(Convert.ToInt32(5.5));//第一位小数为5时，5.5在5和6之间，输出偶数6Console.WriteLine(Convert.ToInt32(5.53));//四舍五入，输出6 5.5 函数 函数好比是对象的动作行为。 在定义函数要想好函数所承担的作用，职责（作用）越单一越好。 函数命名规范 函数命名使用大驼峰命名，即开头首字母大写 多个单词拼接时，所有单词首字母大写 123Add();AddCount();GetUserInfo(); 函数的参数设置&amp;传参行为&amp;返回值 参数可认为是外部需要函数帮忙处理的数据。 外部通过传递参数的形式，将需要处理的数据交给函数处理。 函数返回值可以认为是外部调用某种行为后得到的一种反馈。 12345678910/// &lt;summary&gt;/// 加法方法/// &lt;/summary&gt;/// &lt;param name=&quot;firstCount&quot;&gt;数字1&lt;/param&gt;/// &lt;param name=&quot;secondCount&quot;&gt;数字2&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public int Add(int firstCount, int secondCount) &#123; int total = firstCount + secondCount; return total;&#125; 5.5.1 参数修饰符①无修饰符：如果一个参数没有用参数修饰符标记，则认为它将按值进行传递，这将意味着被调用的方法收到原始数据的一份副本。 即上端调用方法后，下端修改传来的参数不会对原数据造成影响，即参数在方法中只复制了副本。 示例：方法不对原字符串影响修改 123456789string str1 = &quot;test1&quot;;SendMessage(str1);void SendMessage(string msg) &#123; msg = &quot;change&quot;; Console.WriteLine(msg); // change&#125;Console.WriteLine(str1); // test1 ②out：输出参数由被调用的方法赋值，因此按引用传递，如果被调用的方法没有给输出参数赋值，就会出现编译错误。 方法中out修饰的参数，一定要在方法内得到赋值 调用者可不赋初值，甚至可直接将声明变量写在方法调用传参中 即上下端的参数指向同一个地址，修改都会受到影响。 out最大的用途就是调用者只使用一次方法的调用就能获得多个返回值。 在C#7.0中要实现一次方法的调用就能获得多个返回值，建议使用元组。 示例： 1234567891011121314151617181920/* 1.方法中的修改作用到原字符串 */string str1 = &quot;test1&quot;;SendMessage(out str1);void SendMessage(out string msg) &#123; msg = &quot;change&quot;; Console.WriteLine(msg); // change&#125;Console.WriteLine(str1); // change/* 2.调用方法返回多个返回值 */// 这里直接在方法调用的out参数上声明变量string res = SellHouse(100, 1000, out string wantPrice);Console.WriteLine(res);Console.WriteLine(wantPrice);string SellHouse(int area, int price, out string wantPrice) &#123; wantPrice = &quot;出价&quot; + (area * price - 1); return &quot;张三买房&quot;;&#125; ③ref：调用者必须赋初值，并且可以由被调用的方法可选的重新赋值（数据是按引用传递的）。如果被调用的方法未能给ref参数赋值，也不会有编译器错误。 方法中ref修饰的参数，方法内未得到赋值不报错，和out不同。 但是调用者必须赋初值，否则报错。 示例： 12345678string str1 = &quot;test&quot;;//string str1; 报错SendMessage(ref str1);void SendMessage(ref string msg) &#123; msg = &quot;test2&quot;; Console.WriteLine(msg); // test&#125;Console.WriteLine(str1); // test ④params：这个参数修饰符允许将一组可变的数量的参数作为单独的逻辑参数进行传递，方法只能有一个params修饰符，而且必须是方法的最后一个参数。（就是可变参数） 总结out和ref的区别 out修饰的参数必须在方法内修改，而ref可以修改也可以不修改 out在传入参数的时候，参数是局部变量的话，可以不用赋值，因为out一定会对其进行赋值 out参数方法中必须赋值，所以可不需要初始值 而ref修饰的参数，在实参必须有初始值才能调用。因为ref修饰的不一定会给它赋值 因为方法中不一定给ref参数赋值，所以一定要有初始值 out修饰参数可在调用方法时直接声明变量，ref则不行 6.面向对象编程（OOP）6.1 面向对象编程基本概念 面向对象编程一一Object Oriented Programming简写OOP 之前所接触到的编程方式叫做面向过程 面向过程和面向对象是两种不同的编程方式 对比面向过程的特点，可以更好的了解什么是面向对象 过程和函数 过程是早期的一个编程概念 过程类似于函数，只能执行，但是没有返回值 函数不仅能执行，还可以返回结果 面向过程——强调怎么做？ 把完成某一个需求的所有步骤从头到尾逐步实现 根据开发需求，将某些功能独立的代码封装成一个又一个函数 最后完成的代码，就是顺序的调用不同的函数 特点： 注重步骤与过程，不注重职责分工 如果需求复杂，代码会变得很复杂 复杂项目，没有固定的套路，难度很大 比如一个主函数，自顶向下调用多个子函数，这几个子函数又会去调用多个子子函数，形成树的结构 面向对象逻辑——强调谁来做？ 相比较函数，面向对象是更大的封装，根据职责，在一个对象中封装多个方法 在完成某一个需求前，首先确定职责，要做的事情（方法） 根据职责确定不同的对象，在对象内部封装不同的方法（多个） 最后完成代码，就是顺序的让不同的对象调用不同的方法 特点： 注重对象和职责，不同的对象承担不同的职责 更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供固定套路 需要在面向过程基础上，再学习一些面向对象的语法 6.2 类和对象概念 类和对象是面向对象编程的两个核心概念 类是对一群具有相同特征或者行为的事物的一个统称，是抽象的，不能直接使用 特征被称为属性 行为被称为方法 例如：类相当于制汽车是的图纸，是一个模板，是负责创建对象的 对象 对象是由类创造出来的一个具体存在，可以直接使用 由哪一个类创造出来的对象，就拥有在哪一个类中定义的属性和方法 对象就相当于用图纸制造的汽车 先有类，再有对象 类和对象的关系 类是模板，对象是根据类这个模板创建出来的，应该先有类，再有对象 类只有一个，而对象可以有很多个 不同的对象之间属性的具体内容可能各不相同 类中定义了什么属性和方法，对象中就有什么属性和方法，不可能多，也不可能少 6.3 类的设计 在使用面向对象开发前，应该首先分析需求，确定一下程序中需要包含哪些类 在程序开发中要设计一个类，通常需要满足以下三个要素： 1.类名这类事物的名称，满足大驼峰命名法 2.属性这类事物具有什么样的特征 3.方法这类事物具有什么样的行为 类名的确定 名词提炼法分析整个业务流程，出现的名词，通常就是找到的类。 属性和方法的确定 对对象的特征，描述通常可以定义成属性。 对象具有的行为通常可以定义为方法。注：方法一般是动作即动词 提示：需求没有涉及的属性或者方法在设计类时，不需要考虑，即可忽略。 6.4 类和对象的使用6.4.1 声明类 声明一个类需要使用class关键字 类的属性及方法写在&#123;&#125;中 步骤：vs中右键项目名——添加——类 123public class Person &#123; &#125; 6.4.2 声明属性 属性在C#中较为独特，它既不同于方法，也不同于字段。 属性依旧遵循大驼峰命名法 属性最常用的书写方法：public int Age &#123;get; set;&#125; 如果属性中具有get关键字，说明可以获取该属性的值。 如果属性中具有set关键字，说明可以向该属性设置值。 如果没有get和set关键字，则无法获取属性值以及设置属性值 1234567namespace Csharp_Class &#123; public class Person &#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public int Height &#123; get; set; &#125; &#125;&#125; vs快捷编码 - 自动属性模板：输入props，按2次Tab，自动生成一个属性声明的模板 6.4.3 声明方法 详见函数初识 1234567891011121314namespace Csharp_Class &#123; public class Person &#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public int Height &#123; get; set; &#125; public void Eat() &#123; MessageBox.Show(&quot;吃&quot;); &#125; public void Run() &#123; MessageBox.Show(&quot;跑&quot;); &#125; &#125;&#125; 6.4.4 实例化 类使用关键字new实例化对象。 一个类可以实例化多个对象。 对象可以使用类定义的属性和方法。 1234567891011121314151617/* 在另一个类中实例化前面的类，并使用 */namespace Csharp_Class &#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void Form1_Load(object sender, EventArgs e) &#123; Person p = new Person(); p.Name = &quot;zhangsan&quot;; p.Age = 29; p.Eat(); p.Run(); &#125; &#125;&#125; 6.4.5 对象初始化器 在实例化之时，就对其属性进行赋值。 即实例化后直接跟随一个大括号，其中写明属性的赋值，注意这之中分隔符为逗号 可以不带括号了，直接连接大括号 12345678910111213141516/* 在另一个类中实例化前面的类，并使用 */namespace Csharp_Class &#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void Form1_Load(object sender, EventArgs e) &#123; // 拓展：对象初始化器：在实例化之时，就对其属性进行赋值 Person p2 = new Person() &#123; Age = 18, Name = &quot;zhangsan&quot; &#125;; &#125; &#125;&#125; 6.4.6 访问修饰符 public：公有的所有的类都可以访问 private：私有的当前类内部可访问 protected：受保护的当前类以及继承他的子类可访问 internal：内部的只限于本项目内访问，其他的不能访问。 protected internal：内部保护访问只能是本项目内部或子类访问其他类不能访问 访问级别约束： 父类子类访问修饰符要保持一致 方法的访问修饰符 要和 方法参数的访问修饰符 保持一致 注意：类的访问级别 默认为隐式私有，因此需要加上public才可让外部访问 6.4.7 static 静态方法、属性 静态属性和方法 通过**static关键字**修饰 静态属性和方法 可以通过类型直接获取，非静态则必须通过实例化的对象获取 静态类 静态类通过**static关键字**修饰 一般情况下类型不需要使用静态修饰，只有当类型中存在扩展方法时需要使用静态类 7.集合&amp;字典的使用7.1 集合的使用 集合与数组比较类似，都用于存放一组值 7.1.1 数组的优劣分析优势 数组在内存中是连续存储的，所以它的索引速度是非常的快，而且赋值与修改元素也很简单。 劣势 在数组的两个数据间插入数据很麻烦 在声明数组的时候，必须同时指明数组的长度，数组的长度过长，会造成内存浪费，数组和长度过短，会造成数据溢出的错误 7.1.2 ArrayList的使用 ArrayList是 .NET Framework 提供的用于数据存储和检索的专用类 它是命名空间 System.Collections下的一部分 ArrayList的优势 ArrayList的大小是按照其中存储的数据来动态扩充与收缩的 在声明 ArrayList 对象时并不需要指定它的长度 ArrayList可以很方便的进行数据的添加，插入和移除 123456ArrayList arrayList = new ArrayList();arrayList.Add(123);arrayList.Add(&quot;abc&quot;);arrayList.Insert(1, 123 + &quot;abc&quot;);arrayList.RemoveAt(0);arrayList.Remove(&quot;abc&quot;); 从上面示例看，ArrayList好像是解决了数组中所有的缺点，那么它应该就是完美的。 可是在C#2.0 后又出现了List集合，这是为何？ ArrayList的劣势 ArrayList在存储数据时时是使用 object类型 进行存储的 object是所有类的父类（父类可接收子类的对象） ArrayList不是类型安全的，使用时很可能会出现类型不匹配的错误 就算都有插入了统一类型的数据，但在使用的时候，也需要将它们从object转化为对应的原类型来处理 ArrayList的存储存在 装箱 和 拆箱 操作，导致其性能低下 7.1.3 装箱与拆箱的概念 装箱：将比如int类型或者string等 不同类型的对象 通过 隐式转换 赋给object对象。（子赋给父） 12int i = 123;object o = i; 拆箱：将 object对象 通过显式转换 赋给int类型的变量（父转换为子） 显式转换的前提是，被转换者的类型确实是这个类型。否则报错 12object o = 123;int i = (int)o; 装箱与拆箱的过程会产生较多的性能损耗。 正是因为ArrayList存在 不安全类型 与 装箱拆箱 的缺点，所以在C#2.0后出现了泛型的概念。 泛型的概念在此先不多做表述，可以简单理解成：限制集合只能够存储单一类型数据的一种手段 7.1.4 List集合 目前只学习List集合这一种类型即可，以此为突破口，以后再学习其他集合就会非常容易 List集合的声明 List集合与ArrayList由于都继承成了相同的接口，故使用与ArrayList相似。 在声明List集合时，需要同时为其声明List集合内数据的对象类型 示例：List&lt;int&gt; intList = new List&lt;int&gt;() 接口：限制和规定类型行为即类型方法的一种手段。 12345678910111213List&lt;int&gt; ints = new List&lt;int&gt;();ints.Add(1);//ints.Add(&quot;abc&quot;);ints[0] = 2;ints[1] = 3;ints.Insert(0, 5);ints.RemoveAt(0);ints.Remove(2);// 对象初始化器方式List&lt;int&gt; ints2 = new List&lt;int&gt; &#123; 1,2,3,4,5&#125;;ints2.Clear(); 上例中，如果往List集合中插入string字符串”abc”，系统就会报错，且不能通过编译。这样就避免了前面讲的类型安全问题与装箱拆箱的性能问题 在List集合中使用自己创建的类 12345678910111213141516171819202122internal class Person &#123; public int Age &#123; get; set; &#125; public string Name &#123; get; set; &#125; public int Height &#123; get; set; &#125;&#125;List&lt;Person&gt; people = new List&lt;Person&gt;();Person person1 = new Person &#123; Age = 18, Height = 178, Name = &quot;张三&quot;&#125;;people.Add(person1);people.Add(person1);people.Add(new Person &#123; Age = 18, Height = 178, Name = &quot;张三&quot;&#125;);Person person2 = people[0];people.RemoveAt(0);people.Remove(person1); 注意remove方法删除的是指定地址的对象，而每次new出来的对象即使属性相同但是地址不同，还是不同的对象，那么就不能同时被删除掉 总结 集合与数组比较类似，都用于存放一组值 集合中提供了特定的方法能直接操作集合中的数据，并提供了不同的集合类来实现特定的功能 简单的说就是数组的升级版。 他可以动态的对集合的长度（也就是集合内最大元素的个数）进行定义和维护 List泛型的好处指通过允许指定 泛型类或方法 操作的 特定类型， 减少了类型 强制转换 的需要和运行时错误的可能性，泛型提供了类型安全，但没有增加开销。（不会发生装箱和拆箱） 7.2 字典的使用 即一个萝卜一个坑，每一个标记有不重复编号的坑都只能放一个萝卜或者其它东西 Dictionary有 key(键) 和 value(值)，一个键只能对应一种值 一个value可以有很多key，但是key是唯一的。 比如学生是唯一的，成绩不唯一 总结：键唯一，值不唯一 Dictionary声明 在声明Dictionary字典时，需要同时为其声明Dictionary字典内键与值的类型。 示例：Dictionary&lt;int,string&gt; dictionary = new Dictionary&lt;int, string&gt;() 123456789101112131415Dictionary&lt;int, string&gt; dictionary = new Dictionary&lt;int, string&gt;();// 方式一：Add方法赋值dictionary.Add(1, &quot;98分&quot;);dictionary.Add(2, &quot;92分&quot;);dictionary.Add(3, &quot;89分&quot;);dictionary.Add(1, &quot;88分&quot;); // 运行后系统会报错（重复键）// 方式二：索引器赋值dictionary[1] = &quot;88分&quot;; //系统不报错dictionary[4] = &quot;99分&quot;;// 方式三：对象初始化器Dictionary&lt;string, string&gt; dictionary2 = new Dictionary&lt;string, string&gt; &#123; &#123; &quot;A&quot;, &quot;aa&quot; &#125;, &#123; &quot;B&quot;, &quot;bb&quot; &#125;, &#123; &quot;C&quot;, &quot;cc&quot; &#125;&#125;; Dictionary取值和删除 Dictionary索引器中写的键，获取到的是单个的对应值 1234567891011//获取键为1的值// 方式一：索引器取值string value = dictionary[1];// 方式二：foreach遍历取值（这里遍历项就是每一个小键值对，用KeyValuePair专门定义可设置或检索的键值对）foreach (KeyValuePair&lt;int, string&gt; item in dictionary) &#123; string value2 = item.Value;&#125;// 移除键为1的键值对dictionary.Remove(1); 总结 键与值可以是任何类型， 但是键必须在设置时是唯一的， 而值可以不唯一 使用Add(）方法添加键值对，不可添加已有的键名 索引模式可以 新赋值 也可以 修改 已有的键值（注意不是下标） 字典是键值对的集合 7.3 foreach使用 foreach就是传说中的增强for循环或者称作foreach循环 foreach对遍历字典或集合具备天然优势， 效率高过for循环 它循环的对象继承了迭代器 foreach操作数组 12345int[] ints = &#123; 1,2,3,4 &#125;;foreach (int item in ints) &#123; // 每次循环，其item都是整型数组中的一个元素 MessageBox.Show(item.ToString());&#125; foreach操作集合 12345List&lt;int&gt; intList = new List&lt;int&gt; &#123; 1,2,3,4 &#125;;foreach (int item in intList) &#123; // 每次循环，其item都是List集合中的一个元素 MessageBox.Show(item.ToString());&#125; foreach操作字典 这里的item就是一个小键值对 1234foreach (KeyValuePair&lt;int, string&gt; item in dictionary) &#123; int key0 = item.Key; string value0 = item.Value;&#125; 使用var类型推断 var关键字的作用是推断类型，声明的时候必须赋值。赋值到什么类型就成为什么类型 12345List&lt;int&gt; listInt = new List&lt;int&gt; &#123; 1, 2, 3, 4 &#125;;foreach (var item in listInt)&#123; Console.WriteLine(item);&#125; 那么至此C#大概常用的简单语法就学完了","tags":["C#"],"categories":["DOTNET"]},{"title":"开始","path":"/blog/2023-02-28-start/","content":"从博客的博客的博客中看到了以下内容，我觉得确实，随便写点东西也会有用的。 日记的作用作者链接: 对6年日记|的观察ᕕ( ᐛ )ᕗ 赫尔曼的博客 (bearblog.dev) 编程有一个术语叫做”橡皮鸭”，指的是这样一种场景: 程序员遇到一个特别困难的问题，有时会找到其他人，向他人描述这个问题，希望其他人给点建议。 但是，在描述问题时，为了让他人理解，程序员会逐渐理清思路，有时还没等其他人给出建议，自己就悟到应该怎么解决了。 这样的场景中，其他人的作用完全可以用一个橡皮鸭代替。如果遇到想不清楚的问题，就可以尝试对着一只橡皮鸭来解释这个问题，想象怎么描述，可以让橡皮鸭理解这个问题。 在某些方面，作者觉得，日记就是他的橡皮鸭。 在日记里面描述那些困难的问题，可以帮助理清思路，构建想法，反思自己的做法和情绪，并锻炼自己更好的表达能力。 他说他已经坚持写日记六七年。","tags":["journal"],"categories":["日记"]},{"title":"便笺","path":"/notes/index.html","content":"TOC便笺"},{"path":"/about/index.html","content":"关于本站本站就是一个普通的博客网站，没啥东西。就目前个人而言，还啥都不会"}]