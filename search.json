[{"title":"学习和远程联机","path":"/blog/2023-03-15-journal/","content":"学了下习，远程联机玩了下游戏 学习学习了网络安全的基础知识，下了好几个工具，接下来就准备开始靶场练习了。 外设开寝室门的时候，耳机摔坏了，这是第二个坏掉的有线耳机。 有线耳机戴着舒服一些，不然肯定用无线了，当然也是我没钱买高级的无线耳机，现在用的还不小心掉了一个，但是单只用还是凑合的。 然后，电脑爆满了，简单看了下硬盘推荐，买了个1t的移动固态硬盘。 真的是难以预料，安装的东西越来越多，特别是网安后面可能要装几个虚拟机。我使用了好几个工具清理，以及SpaceSniffer去查看容量，手动删除但是无从下手。买一个移动固态硬盘其实也不算是很好的办法。但是无所谓了。 远程联机远程联机的解决方案有很多，我只尝试过小部分。 steam的远程畅玩需要比如uu加速器的加速，但是这个需要一定的付费。 然后是parsec，虽然免费，而且很多人推荐使用。但是移动直接把它墙了，通过更多手段用起来延迟也很高了，而且墙之前试过，校园网里使用，不知道是不是个人原因，使用起来延迟不低。 还有腾讯会议，这个还是不错的，成功玩过多次游戏，延迟小，而且免费，不过好像只能2个人使用。有时候需要3个人的场景，就不行了。 最后找到闪门，这个应该是可以多人使用的，但是之前尝试时候是2个人，打完了一把游戏。延迟不高，感觉好像还行，但是需要付费。这个费用好像能承受，之后看看3人的效果怎么样再说了。","tags":["journal"],"categories":["日记"]},{"title":"第二周的结束","path":"/blog/2023-03-13-journal/","content":"第二周的结束，摸鱼 摸鱼这周，摸鱼了很多，周末也没有学很多东西。第二周结束了，下周再努力吧XD","tags":["journal"],"categories":["日记"]},{"title":"C#之反射注入简单练习","path":"/blog/2023-03-12-csharp/","content":"C#之AutoFac 简单练习，使用反射的方式并区分生命周期进行反射依赖注入 反射注入简单练习 首先要安装一个Nuget包：Microsoft.Extensions.DependencyModel 用于获取应用程序及其依赖项的元数据信息，包括程序集名称、版本号、依赖关系等 支持多种格式的依赖项文件，例如项目文件、NuGet包、Assembly文件等 提供了API来查询和操作应用程序的依赖项信息，包括检查程序集是否存在、获取程序集的依赖项列表等 1.获取依赖项 首先获取应用程序的依赖项信息，返回CompilationLibrary集合，其包含了所有被编译进应用程序中的程序集及其依赖项元数据列表 接下来对依赖项集合筛选过滤，返回所有非Serviceable类型且Type为”project”的依赖项。其中，Serviceable表示依赖项是否可服务化，而Type则表示依赖项的类型，”project”表示（自己创建的）项目依赖项，不是来自NuGet等外部源的依赖项 Serviceable：指依赖项是否可被服务化，可服务化程序集一般用于兼容性替代。如果一个程序集被标记为Serviceable，说明它只能被其他程序集引用，而不能被直接加载。 因此，在这里需要排除可服务化的程序集，只加载非服务化的项目程序集。如果不加入该条件，可能获取到不需要的依赖项，那对于去除就会麻烦 以下代码记住就好了 123var libs = DependencyContext.Default .CompileLibraries .Where(x=&gt;!x.Serviceable &amp;&amp; x.Type == &quot;project&quot;).ToList(); 2.获取项目所有程序集的类型 实现通过依赖项的名称制成Assembly AssemblyLoadContext：表示程序集的加载上下文，允许加载和卸载程序集，通过静态属性Default来访问 AssemblyName：表示程序集的完整名称。这里通过使用 lib.Name（当前依赖项的名称）来创建AssemblyName实例，因为方法要用 LoadFromAssemblyName：通过AssemblyName参数加载指定名称的程序集返回Assembly 123456List&lt;Assembly&gt; assemblies = new();foreach (var lib in libs)&#123; assemblies.Add(AssemblyLoadContext.Default .LoadFromAssemblyName(new AssemblyName(lib.Name)));&#125; 3.通过反射程序集的类型注册服务 首先将assemblies程序集中的所有类型注册到Autofac容器中 然后筛选出了所有实现了IocTag接口的非抽象类型（IocTag是自己创建的接口，相当于标签，用于筛选） 将筛选出来的所有类型都注册为自身类型和其实现的所有接口类型 最后是指定注册的服务生命周期为作用域生命周期 1234builder.RegisterAssemblyTypes(assemblies.ToArray()) .Where(t=&gt;t.IsAssignableTo&lt;IocTag&gt;() &amp;&amp; !t.IsAbstract) .AsSelf().AsImplementedInterfaces() .InstancePerLifetimeScope(); 4.区分生命周期的反射注入 为了区分生命周期，将IocTag分为3个生命周期 123456789101112public interface IocTagScope&#123;&#125;public interface IocTagSingleton&#123;&#125;public interface IocTagTransient&#123;&#125; 这里在注册时，就分别对三个生命周期类型进行筛选并注册不同的生命周期类型 并加上了允许属性注入 注册ControllerBase，使用依赖注入框架来管理应用程序中的组件时，也需要将控制器类型注册到容器中 完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System.Reflection;using System.Runtime.Loader;using Autofac;using Microsoft.Extensions.DependencyModel;namespace Demo.Utility;public class DemoUtilityModule : Autofac.Module&#123; protected override void Load(ContainerBuilder builder) &#123; var libs = DependencyContext.Default .CompileLibraries .Where(x=&gt;!x.Serviceable &amp;&amp; x.Type == &quot;project&quot;).ToList(); List&lt;Assembly&gt; assemblies = new(); foreach (var lib in libs) &#123; assemblies.Add(AssemblyLoadContext.Default .LoadFromAssemblyName(new AssemblyName(lib.Name))); &#125; builder.RegisterAssemblyTypes(assemblies.ToArray()) .Where(t =&gt; t.IsAssignableTo&lt;IocTagScope&gt;() &amp;&amp; !t.IsAbstract) .AsSelf().AsImplementedInterfaces() .InstancePerLifetimeScope() .PropertiesAutowired(); builder.RegisterAssemblyTypes(assemblies.ToArray()) .Where(t =&gt; t.IsAssignableTo&lt;IocTagSingleton&gt;() &amp;&amp; !t.IsAbstract) .AsSelf().AsImplementedInterfaces() .SingleInstance() .PropertiesAutowired(); builder.RegisterAssemblyTypes(assemblies.ToArray()) .Where(t =&gt; t.IsAssignableTo&lt;IocTagTransient&gt;() &amp;&amp; !t.IsAbstract) .AsSelf().AsImplementedInterfaces() .PropertiesAutowired(); builder.RegisterAssemblyTypes(assemblies.ToArray()) .Where(t =&gt; t.IsAssignableTo&lt;ControllerBase&gt;() &amp;&amp; !t.IsAbstract) .AsSelf() .PropertiesAutowired(); &#125;&#125; 此时在一个测试项目中注册模块，随便创建几个接口继承三个IocTag并创建实现类去使用，可见注入成功","tags":["C#"],"categories":["DOTNET"]},{"title":"nodejs仿照express封装框架简单练习","path":"/blog/2023-03-11-nodejs/","content":"Nodejs简单练习，仿照express封装一个简单的框架 1.Nodejs仿照express封装框架1.0 首先封装web静态服务器 如果请求来的不是favicon.ico，就去找静态资源里的相应文件相应回去给浏览器展示 12345678910111213141516171819202122const fs = require(&#x27;fs&#x27;);const http = require(&#x27;http&#x27;);http.createServer(function (req, res) &#123; //获取地址 let pathname = req.url // 如果访问/就也加载index.html pathname = pathname == &#x27;/&#x27; ? &#x27;/index.html&#x27; : pathname //通过fs模块读取文件 if (pathname == &#x27;/favicon.ico&#x27;) res.end() fs.readFile(&#x27;./static&#x27; + pathname, (err, data) =&gt; &#123; if (err) &#123; //找不到文件错误时，应设置404响应头 res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;这个页面不存在&#x27;) &#125; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125;)&#125;).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;); 此时发现进去网页无法呈现css样式，那么就需要修改。 因为css文件的请求，不能也把响应头设置为text&#x2F;html，而是text&#x2F;css，其它文件如js类似，所以应该根据每一个请求的文件的后缀名去动态设置相应的响应头 首先创建module&#x2F;common.js 12345exports.getMime = function(extname)&#123; extname = extname.slice(1) if (extname == &#x27;&#x27;) extname == &#x27;html&#x27; return &#x27;text/&#x27; + (extname == &#x27;js&#x27; ? &#x27;javascript&#x27; : extname)&#125; app.js中导入自定义模块，动态设置响应头 123456789101112131415161718192021222324252627const fs = require(&#x27;fs&#x27;);const http = require(&#x27;http&#x27;);const path = require(&#x27;path&#x27;);const common = require(&#x27;./module/common.js&#x27;)http.createServer(function (req, res) &#123; //获取地址 let pathname = req.url // 如果访问/就也加载index.html pathname = pathname == &#x27;/&#x27; ? &#x27;/index.html&#x27; : pathname //获取文件后缀名 let extname = path.extname(pathname) //通过fs模块读取文件 if (pathname == &#x27;/favicon.ico&#x27;) res.end() fs.readFile(&#x27;./static&#x27; + pathname, (err, data) =&gt; &#123; if (err) &#123; //找不到文件错误时，应设置404响应头 res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;这个页面不存在&#x27;) &#125; let mime = common.getMime(extname) res.writeHead(200, &#123; &#x27;Content-Type&#x27;: mime + &#x27;;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125;)&#125;).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;); 此时发现json文件请求还是不行，那么继续优化。 检查请求可见，对json文件的请求是这样的：http://127.0.0.1:3000/json/all.json?9498807885421825 那么就需要只获取签名的路径部分，请求参数不应该获取 那么就可以使用url模块解析只取除去请求参数的路径 12345678910111213141516171819202122232425262728const fs = require(&#x27;fs&#x27;);const http = require(&#x27;http&#x27;);const path = require(&#x27;path&#x27;);const url = require(&#x27;url&#x27;);const common = require(&#x27;./module/common.js&#x27;)http.createServer(function (req, res) &#123; //获取地址，用URL对象获取去除请求参数的请求路径 let pathname = url.parse(req.url).pathname // 如果访问/就也加载index.html pathname = pathname == &#x27;/&#x27; ? &#x27;/index.html&#x27; : pathname //获取文件后缀名 let extname = path.extname(pathname) //通过fs模块读取文件 if (pathname == &#x27;/favicon.ico&#x27;) res.end() fs.readFile(&#x27;./static&#x27; + pathname, (err, data) =&gt; &#123; if (err) &#123; //找不到文件错误时，应设置404响应头 res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;这个页面不存在&#x27;) &#125; let mime = common.getMime(extname) res.writeHead(200, &#123; &#x27;Content-Type&#x27;: mime + &#x27;;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125;)&#125;).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;); 但是响应类型还是不够健全，因为很多都不只是单个后缀名就是了，那么就需要优化 通过一个记录了全部后缀类型和请求头对应关系的文件来设置即可（data&#x2F;mime.json） 先读取这个json文件，再转为对象形式，在通过文件后缀名得到请求头对应设置字符 common.js 1234567891011121314151617181920212223const fs = require(&#x27;fs&#x27;);exports.getMime = function (extname) &#123; extname = extname.slice(1) if (extname == &#x27;&#x27;) extname == &#x27;html&#x27; return &#x27;text/&#x27; + (extname == &#x27;js&#x27; ? &#x27;javascript&#x27; : extname)&#125;exports.getFileMime = function (extname) &#123; //异步方法不能直接返回这里得到的值，应要封装为一个promise return new Promise((resolve, reject) =&gt; &#123; fs.readFile(&#x27;./data/mime.json&#x27;, &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) return reject(err) resolve(JSON.parse(data)[extname]) &#125;) &#125;)&#125;//同步方式读取文件（必须等待此执行完毕）exports.getFileMimeSync = function (extname) &#123; let data = fs.readFileSync(&#x27;./data/mime.json&#x27;, &#x27;utf-8&#x27;) return JSON.parse(data)[extname]&#125; app.js 1234567891011121314151617181920212223242526272829303132const fs = require(&#x27;fs&#x27;);const http = require(&#x27;http&#x27;);const path = require(&#x27;path&#x27;);const url = require(&#x27;url&#x27;);const common = require(&#x27;./module/common.js&#x27;)http.createServer(function (req, res) &#123; //获取地址，用URL对象获取去除请求参数的请求路径 let pathname = url.parse(req.url).pathname // 如果访问/就也加载index.html pathname = pathname == &#x27;/&#x27; ? &#x27;/index.html&#x27; : pathname //获取文件后缀名 let extname = path.extname(pathname) //通过fs模块读取文件 if (pathname == &#x27;/favicon.ico&#x27;) res.end() fs.readFile(&#x27;./static&#x27; + pathname, async (err, data) =&gt; &#123; if (err) &#123; //找不到文件错误时，应设置404响应头 res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;这个页面不存在&#x27;) &#125; // 因为是异步的，所以用await和async来搞 let mime = await common.getFileMime(extname) res.writeHead(200, &#123; &#x27;Content-Type&#x27;: mime + &#x27;;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125;)&#125;).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;); 1.1 封装使一行代码创建静态web服务目的：只需传入静态web文件目录，一行代码即可创建服务 首先修改上文的common.js为routes.js，将app.js中用于创建web服务的代码封装 routes.js 12345678910111213141516171819202122232425262728293031323334353637383940414243const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const url = require(&#x27;url&#x27;);//私有方法let getFileMime = function (extname) &#123; //异步方法不能直接返回这里得到的值，应要封装为一个promise return new Promise((resolve, reject) =&gt; &#123; fs.readFile(&#x27;./data/mime.json&#x27;, &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) return reject(err) resolve(JSON.parse(data)[extname]) &#125;) &#125;)&#125;//同步方式读取文件（必须等待此执行完毕）getFileMimeSync = function (extname) &#123; let data = fs.readFileSync(&#x27;./data/mime.json&#x27;, &#x27;utf-8&#x27;) return JSON.parse(data)[extname]&#125;// static创建静态web服务exports.static = function (req, res, staticPath) &#123; //获取地址，用URL对象获取去除请求参数的请求路径 let pathname = url.parse(req.url).pathname // 如果访问/就也加载index.html pathname = pathname == &#x27;/&#x27; ? &#x27;/index.html&#x27; : pathname //获取文件后缀名 let extname = path.extname(pathname) //通过fs模块读取文件 if (pathname == &#x27;/favicon.ico&#x27;) res.end() // 这里动态传入static地址 fs.readFile(&#x27;./&#x27; + staticPath + pathname, async (err, data) =&gt; &#123; if (err) &#123; //找不到文件错误时，应设置404响应头 res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;这个页面不存在&#x27;) &#125; let mime = await getFileMime(extname) res.writeHead(200, &#123; &#x27;Content-Type&#x27;: mime + &#x27;;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125;)&#125; app.js 12345678910const http = require(&#x27;http&#x27;);const routes = require(&#x27;./module/routes.js&#x27;);http.createServer(function (req, res) &#123; // 创建静态web服务 routes.static(req,res,&#x27;./static&#x27;)&#125;).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;); 1.2 构建基础的路由官方解释： 路由（Routing）是由一个URI（或者叫路径）和一个特定的HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问。 通俗的说： 路由指的就是针对不同请求的URL，处理不同的业务逻辑。 案例：将上文项目添加路由配置 首先routes.js中读取文件的操作需要改为同步，否则将访问index.html时还未创建完web服务导致访问变成404 需要确保路由配置和静态资源托管之间不干扰 123456789101112131415161718192021222324252627282930313233343536const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const url = require(&#x27;url&#x27;);//私有方法let getFileMime = function (extname) &#123; var data = fs.readFileSync(&#x27;./data/mime.json&#x27;); //同步方法 let mimeObj = JSON.parse(data.toString()); return mimeObj[extname];&#125;exports.static = function (req, res, staticPath) &#123; //1、获取地址 let pathname = url.parse(req.url).pathname; let extname = path.extname(pathname); if (extname) &#123; //如果有后缀名让静态web处理 否则路由处理 //2、通过fs模块读取文件 if (pathname != &#x27;/favicon.ico&#x27;) &#123; try &#123; let data = fs.readFileSync(&#x27;./&#x27; + staticPath + pathname); if (data) &#123; let mime = getFileMime(extname); res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;&#x27; + mime + &#x27;;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125; &#125; catch (error) &#123; console.log(error) &#125; &#125; &#125;&#125; app.js 12345678910111213141516171819202122232425262728293031323334const http = require(&#x27;http&#x27;);const path = require(&#x27;path&#x27;);const url = require(&#x27;url&#x27;);const routes = require(&#x27;./module/routes&#x27;);http.createServer(function (req, res) &#123; //创建静态web服务，其中读取文件异步改1同步，保证先创建完服务后，再进行路由的配置 // 否则访问index.html时候服务还没创建完，路由匹配到404 routes.static(req, res, &#x27;static&#x27;); //路由 let pathname = url.parse(req.url).pathname; let extname = path.extname(pathname); if (!extname) &#123; //如果有请求地址有后缀名的话让静态web服务去处理 if (pathname == &#x27;/login&#x27;) &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&quot;执行登录&quot;); &#125; else if (pathname == &#x27;/register&#x27;) &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&quot;执行注册&quot;); &#125; else if (pathname == &#x27;/admin&#x27;) &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&quot;处理后的业务逻辑&quot;); &#125; else &#123; res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&quot;404&quot;); &#125; &#125;&#125;).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;); 1.3 使用EJS模板引擎新建一个views文件夹，其中放置一个login.ejs 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;ejs&lt;/h1&gt; &lt;h3&gt; &lt;%=msg%&gt; &lt;br&gt; &lt;ul&gt; &lt;% for(let i=0;i&lt;list.length;i++)&#123;%&gt; &lt;li&gt;&lt;%=list[i].title%&gt;&lt;/li&gt; &lt;%&#125; %&gt; &lt;/ul&gt; &lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; app.js中对&#x2F;login页面渲染时使用ejs 1234567891011121314151617181920212223if (pathname == &#x27;/login&#x27;) &#123; /* res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&quot;执行登录&quot;); */ let msg = &#x27;数据库数据&#x27; let list = [ &#123; title: &#x27;新闻1&#x27; &#125;, &#123; title: &#x27;新闻2&#x27; &#125;, &#123; title: &#x27;新闻3&#x27; &#125;, &#123; title: &#x27;新闻4&#x27; &#125;, ] ejs.renderFile(&#x27;./views/login.ejs&#x27;,&#123;msg,list&#125;,(err, data)=&gt; &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data) &#125; ) &#125; 1.4 原生的get和post使用 获取get传值就是对url解析后的query属性获取，注意url.parse加一个true参数表示解析成对象 而post获取传值则是以文件流的形式的，需要以文件流的方式读取数据 即on监听data事件不断对传来的数据拼接，后面监听end事件即数据接收完毕 form.ejs 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/doLogin&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;br&gt; &lt;br&gt; 密 码: &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;br&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; app.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const http = require(&#x27;http&#x27;);const url = require(&#x27;url&#x27;);const path = require(&#x27;path&#x27;);const ejs = require(&#x27;ejs&#x27;);const routes = require(&#x27;./module/routes&#x27;);const querystring = require(&quot;querystring&quot;); http.createServer(function (req, res) &#123; //创建静态web服务 routes.static(req, res, &#x27;static&#x27;); //路由 let pathname = url.parse(req.url).pathname; //http://127.0.0.1:3000/news?page=2&amp;id=1 //获取请求类型 console.log(req.method); let extname = path.extname(pathname); if (!extname) &#123; //如果有后缀名的话让静态web服务去处理 if (pathname == &#x27;/&#x27;) &#123; //获取get传值 res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;首页&#x27;); &#125; else if (pathname == &#x27;/news&#x27;) &#123; //获取get传值 var query = url.parse(req.url, true).query; console.log(query.page); res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;get传值获取成功&#x27;); &#125; else if (pathname == &#x27;/login&#x27;) &#123; //post演示 ejs.renderFile(&quot;./views/form.ejs&quot;, &#123;&#125;, (err, data) =&gt; &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data) &#125;) &#125; else if (pathname == &#x27;/doLogin&#x27;) &#123; //获取post传值 let postData = &#x27;&#x27;; req.on(&#x27;data&#x27;, (chunk) =&gt; &#123; postData += chunk; &#125;) req.on(&#x27;end&#x27;, () =&gt; &#123; try &#123; postData = JSON.parse(postData) &#125; catch (e) &#123; &#125; req.query = postData // querystring.parse()方法用于将URL查询字符串解析为包含查询URL的键和对值的对象。 console.log(querystring.parse(postData)) &#125;) &#125; else &#123; res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;404&#x27;); &#125; &#125;&#125;).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;); 1.5 模块化方式抽取封装前面app.js中的代码 在routes.js中封装一个对象app，其中分别封装static创建静态web服务，以及上文的几个路由 注意这之后，app.js中需要动态的方式去调用routes.js中封装在对象里的方法：routes[pathname](req, res) routes.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const url = require(&#x27;url&#x27;);const ejs = require(&#x27;ejs&#x27;);//私有方法let getFileMime = function (extname) &#123; var data = fs.readFileSync(&#x27;./data/mime.json&#x27;); //同步方法 let mimeObj = JSON.parse(data.toString()); return mimeObj[extname];&#125;let app = &#123; static: (req, res, staticPath) =&gt; &#123; //1、获取地址 let pathname = url.parse(req.url).pathname; let extname = path.extname(pathname); //2、通过fs模块读取文件 if (pathname != &#x27;/favicon.ico&#x27; &amp;&amp; extname) &#123; try &#123; let data = fs.readFileSync(&#x27;./&#x27; + staticPath + pathname); if (data) &#123; let mime = getFileMime(extname); res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;&#x27; + mime + &#x27;;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125; &#125; catch (error) &#123; &#125; &#125; &#125;, login: (req, res) =&gt; &#123; ejs.renderFile(&#x27;./views/form.ejs&#x27;, &#123;&#125;, (err, data) =&gt; &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data) &#125;) &#125;, news: (req, res) =&gt; &#123; res.end(&#x27;news&#x27;); &#125;, doLogin: (req, res) =&gt; &#123; //获取post传值 let postData = &#x27;&#x27;; req.on(&#x27;data&#x27;, (chunk) =&gt; &#123; postData += chunk; &#125;) req.on(&#x27;end&#x27;, () =&gt; &#123; console.log(postData); res.end(postData); &#125;) &#125;, error: (req, res) =&gt; &#123; res.end(&#x27;404&#x27;); &#125;&#125;// app.login(&#x27;req&#x27;,&#x27;res&#x27;)// app[&#x27;login&#x27;](&#x27;req&#x27;,&#x27;res&#x27;)module.exports = app; app.js 1234567891011121314151617181920212223242526const http = require(&#x27;http&#x27;);const routes = require(&#x27;./module/routes&#x27;);const url = require(&#x27;url&#x27;);const path = require(&#x27;path&#x27;);http.createServer(function (req, res) &#123; //创建静态web服务 routes.static(req, res, &#x27;static&#x27;); //路由 let pathname = url.parse(req.url).pathname.replace(&quot;/&quot;, &quot;&quot;); //http://127.0.0.1:3000/news pathname=news //http://127.0.0.1:3000/login pathname=login // http://127.0.0.1:3000/xxxx pathname=xxxx app.xxxx不存在 let extname = path.extname(pathname); if (!extname) &#123; //如果有后缀名的话让静态web服务去处理 try &#123; routes[pathname](req, res); &#125; catch (error) &#123; routes[&#x27;error&#x27;](req, res); &#125; &#125;&#125;).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;); 1.6 方法扩展&amp;动态注册方法方法扩展 对app赋值一个函数后，还可以对app声明get等等的新方法扩展方法，这样之后原方法还是不会被覆盖，还可以调用 12345678910111213141516171819202122let app=function()&#123; console.log(&#x27;调用app方法&#x27;)&#125;app.get=function()&#123; console.log(&#x27;get方法&#x27;)&#125;app.post=function()&#123; console.log(&#x27;post方法&#x27;)&#125;//调用// app.get();app(); // 打印出 调用app方法/*---------------此时app对象的结构：----------------*/let app: &#123; (): void; get(): void; post(): void;&#125; 动态注册方法 方法中传入一个字符串和一个回调函数，若要注册方法使之在之后可进行调用。 需要先创建一个全局对象G存储动态创建的方法，使用上面 方法扩展 的方式在G对象中进行动态创建G[&#39;/login&#39;](req, res)。 那么app主方法中判断方法存在，然后调用即可（使用[]访问成员方式调用） 1234567891011121314151617181920212223242526272829303132333435363738394041/*最终目标是以这样的方式配置路由：app.get(&quot;/&quot;, function (req, res) &#123; res.send(&#x27;hello world&#x27;)&#125;)*/// global，表示全局let G = &#123;&#125;let app = function (req, res) &#123; console.log(&#x27;调用app方法&#x27;) if (G[&#x27;/login&#x27;]) &#123; // 执行方法 G[&#x27;/login&#x27;](req, res) &#125;&#125;app.get = function (str, cb) &#123; // 注册方法 // G[&#x27;/login&#x27;] = function (param) &#123; &#125; G[str] = cb&#125;app.post = function () &#123; console.log(&#x27;post方法&#x27;)&#125;// 执行方法// 相当于调用后在全局注册了一个方法app.get(&#x27;/login&#x27;, (req, res) =&gt; &#123; // res.send(&#x27;执行login方法&#x27;) console.log(&#x27;执行login方法&#x27;)&#125;)setTimeout(() =&gt; &#123; app(&#x27;req&#x27;,&#x27;res&#x27;)&#125;, 1000); 1.7 仿照express封装app.get()配置路由express中配置路由示例 接下来将按照express的get方法封装配置路由 1234567891011var express = require(&#x27;express&#x27;)var app = express()app.get(&quot;/&quot;, function (req, res) &#123; res.send(&#x27;hello world&#x27;)&#125;)app.get(&quot;/login&quot;, function (req, res) &#123; res.send(&#x27;hello world&#x27;)&#125;)app.post(&quot;/doLogin&quot;, function (req, res) &#123; res.send(&#x27;POST request to the homepage&#x27;)&#125;) route.js route.js中即用动态注册方法的形式对get方法传来的路径字符串和回调函数创建方法 注意createServer后要获取地址pathname，针对对应地址调用对应注册好的方法 还要对不存在页面进行404页面设置 1234567891011121314151617181920212223242526272829const url= require(&quot;url&quot;)// global，表示全局let G = &#123;&#125; //http://127.0.0.1:3000/news //http://127.0.0.1:3000/login //http://127.0.0.1:3000/registerlet app = function (req, res) &#123; // createServer后获取地址，针对对应地址调用对应注册好的方法 let pathname=url.parse(req.url).pathname if (G[pathname]) &#123; // 执行方法 G[pathname](req, res) &#125;else&#123; res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;页面不存在&#x27;); &#125;&#125;app.get = function (str, cb) &#123; // 注册方法 // G[&#x27;/login&#x27;] = function (param) &#123; &#125; G[str] = cb&#125;module.exports = app test.js http.createServer()中直接传入app代表的route.js即可，使得浏览器每次访问地址，都会触发app方法去执行注册好的方法 12345678910111213141516171819202122232425const http = require(&#x27;http&#x27;);const app = require(&#x27;./module/route&#x27;)// 1.注册web服务/* http.createServer(function (request, response) &#123;&#125;).listen(3000); */http.createServer(app).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;);// 2.配置路由app.get(&#x27;/&#x27;,function(req,res)&#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;首页&#x27;);&#125;)app.get(&#x27;/login&#x27;,function(req,res)&#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;执行登录操作&#x27;);&#125;)app.get(&#x27;/news&#x27;,function(req,res)&#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;新闻页面&#x27;);&#125;) 此时就和express的路由配置大致相同了 1.8 配置post方法先对route.js中的逻辑封装到方法中 1234567891011121314151617181920212223242526const url = require(&quot;url&quot;)let server = () =&gt; &#123; let G = &#123;&#125; let app = function (req, res) &#123; // createServer后获取地址，针对对应地址调用对应注册好的方法 let pathname = url.parse(req.url).pathname if (G[pathname]) &#123; // 执行方法 G[pathname](req, res) &#125; else &#123; res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;页面不存在&#x27;); &#125; &#125; app.get = function (str, cb) &#123; // 注册方法 G[str] = cb &#125; return app&#125;module.exports = server() 封装post方法的问题 首先封装的逻辑还是和get一样，传str和cb在G中注册方法，但是这里就需要对G分离成针对get存储和针对post存储了。否则两个同地址不同请求方法的方法将会覆盖 route.js 如下将G分为_get子对象和_post子对象，凡是get的都存储到_get，post同理。 注意后面的逻辑都要改，以及判断是否为页面不存在，需要在_get和_post子对象中判断G[&#39;_&#39;+method][pathname]是否创建了对应地址的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const url = require(&quot;url&quot;)let server = () =&gt; &#123; let G = &#123;&#125; // 把get和post分开 /* let G1 = &#123;&#125; let G2 = &#123;&#125; */ G._get = &#123;&#125; G._post = &#123;&#125; let app = function (req, res) &#123; // createServer后获取地址，针对对应地址调用对应注册好的方法 let pathname = url.parse(req.url).pathname // 获取请求类型用于分开注册get和post方法 let method = req.method.toLowerCase() if (G[&#x27;_&#x27;+method][pathname]) &#123; // 注意G分为_get和_post后这里也要改 // 执行方法 if (method == &#x27;get&#x27;) &#123; // get G._get[pathname](req, res) &#125; else &#123; // post // 对于post，还需要获取到post的数据，挂载到req.body上 let postData = &#x27;&#x27; req.on(&#x27;data&#x27;,(chunk)=&gt; &#123; postData+=chunk &#125;) req.on(&#x27;end&#x27;,()=&gt; &#123; req.body = postData //扩展req对象属性进行挂载 G._post[pathname](req, res) &#125;) &#125; &#125; else &#123; res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;页面不存在&#x27;); &#125; &#125; //注意这里要把get和post方法注册分开，否则同地址，后面比如post注册的方法会覆盖前面get的 app.get = function (str, cb) &#123; // 注册方法 G._get[str] = cb &#125; app.post = function (str, cb) &#123; // 注册方法 G._post[str] = cb &#125; return app&#125;module.exports = server() test.js 123456789101112131415161718192021222324252627282930313233const http = require(&#x27;http&#x27;);const app = require(&#x27;./module/route&#x27;)const ejs = require(&#x27;ejs&#x27;)// 1.注册web服务/* http.createServer(function (request, response) &#123;&#125;).listen(3000); */http.createServer(app).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;);// 2.配置路由app.get(&#x27;/&#x27;,function(req,res)&#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;首页&#x27;);&#125;)app.get(&#x27;/login&#x27;,function(req,res)&#123; // res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); // res.end(&#x27;执行登录操作&#x27;); ejs.renderFile(&#x27;./views/form.ejs&#x27;,&#123;&#125;,(err,data)=&gt; &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125;)&#125;)app.post(&#x27;/doLogin&#x27;,function(req,res)&#123; console.log(req.body) res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(req.body);&#125;) 测试可见，在访问&#x2F;login后，填写账号密码可显示在浏览器上 同时测试get和post的路径相同，但不会报错 1.9 封装res.send()方法 首先写一个用于扩展res.send()方法的方法，然后后面createServer开始时马上调用对res挂载send方法 1234567891011121314151617181920212223function changeRes(res) &#123; // 为res扩展一个send方法 res.send = (data) =&gt; &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125;&#125;let server = () =&gt; &#123; let G = &#123;&#125; // 把get和post分开 /* let G1 = &#123;&#125; let G2 = &#123;&#125; */ G._get = &#123;&#125; G._post = &#123;&#125; let app = function (req, res) &#123; // createServer时，对res扩展send方法 changeRes(res) // createServer后获取地址，针对对应地址调用对应注册好的方法 let pathname = url.parse(req.url).pathname ...&#125; 1.10 封装静态web服务 创建static目录，下创建css&#x2F;style.css写入样式，启动代码后浏览器调试工具可见style.css传输失败 那么把之前的创建静态web服务相关的文件data和代码复制 G中扩展一个staticPath用于存储静态web服务的文件路径 同时也是在createServer后马上去执行创建静态web服务的逻辑 app扩展一个static方法用于重新设置staticPath路径 route.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const url = require(&#x27;url&#x27;);//扩展resfunction changeRes(res) &#123; res.send = (data) =&gt; &#123; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125;&#125;//根据后缀名获取文件类型function getFileMime(extname) &#123; var data = fs.readFileSync(&#x27;./data/mime.json&#x27;); // 这里还有硬编码的小问题不管了 let mimeObj = JSON.parse(data.toString()); return mimeObj[extname];&#125;//静态web服务的方法function initStatic(req, res, staticPath) &#123; //1、获取地址 let pathname = url.parse(req.url).pathname; // pathname = pathname == &#x27;/&#x27; ? &#x27;/index.html&#x27; : pathname; let extname = path.extname(pathname); //2、通过fs模块读取文件 if (extname) &#123; //如果有后缀名用静态web服务处理 try &#123; let data = fs.readFileSync(&#x27;./&#x27; + staticPath + pathname); if (data) &#123; let mime = getFileMime(extname); res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;&#x27; + mime + &#x27;;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(data); &#125; &#125; catch (error) &#123; console.log(error); &#125; &#125;&#125;let server = () =&gt; &#123; let G = &#123; _get: &#123;&#125;, _post: &#123;&#125;, // G中声明staitcPath（静态web目录） staticPath: &#x27;static&#x27; &#125; // 把get和post分开 /* let G1 = &#123;&#125; let G2 = &#123;&#125; */ let app = function (req, res) &#123; //扩展res的方法 changeRes(res); //配置静态web服务 initStatic(req, res, G.staticPath); let pathname = url.parse(req.url).pathname; //获取请求类型 let method = req.method.toLowerCase(); console.log(method); let extname = path.extname(pathname); if (!extname) &#123; //如果有后缀名用静态web处理 if (G[&#x27;_&#x27; + method][pathname]) &#123; if (method == &quot;get&quot;) &#123; G[&#x27;_&#x27; + method][pathname](req, res); //执行方法 &#125; else &#123; //post 获取post的数据 把它绑定到req.body let postData = &#x27;&#x27;; req.on(&#x27;data&#x27;, (chunk) =&gt; &#123; postData += chunk; &#125;) req.on(&#x27;end&#x27;, () =&gt; &#123; req.body = postData; G[&#x27;_&#x27; + method][pathname](req, res); //执行方法 &#125;) &#125; &#125; else &#123; res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); res.end(&#x27;页面不存在&#x27;); &#125; &#125; &#125; //注意这里要把get和post方法注册分开，否则同地址，后面比如post注册的方法会覆盖前面get的 app.get = function (str, cb) &#123; // 注册方法 G._get[str] = cb &#125; app.post = function (str, cb) &#123; // 注册方法 G._post[str] = cb &#125; // 配置静态web服务路径 app.static = (staticPath) =&gt; &#123; G.staticPath = staticPath &#125; return app&#125;module.exports = server() app.js 1234567891011121314151617181920212223242526272829303132const http = require(&#x27;http&#x27;);const app = require(&#x27;./module/route&#x27;)const ejs = require(&#x27;ejs&#x27;)// 1.注册web服务/* http.createServer(function (request, response) &#123;&#125;).listen(3000); */http.createServer(app).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;);//一行代码配置静态web服务app.static(&#x27;static&#x27;)// 2.配置路由app.get(&#x27;/&#x27;,function(req,res)&#123; res.send(&#x27;首页&#x27;)&#125;)app.get(&#x27;/login&#x27;,function(req,res)&#123; // res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;utf-8&quot;&#x27; &#125;); // res.end(&#x27;执行登录操作&#x27;); ejs.renderFile(&#x27;./views/form.ejs&#x27;,&#123;&#125;,(err,data)=&gt; &#123; res.send(data) &#125;)&#125;)app.post(&#x27;/doLogin&#x27;,function(req,res)&#123; console.log(req.body) res.send(req.body)&#125;) 至此，封装一个类似express框架的项目完成","tags":["Nodejs"],"categories":["Nodejs"]},{"title":"博客应该写什么呢","path":"/blog/2023-03-10-journal/","content":"今天看到了一篇文章，讲述了博客应该要写什么 博客应该写什么呢原文地址：What to blog about 这篇文章中说到了如果没有东西写，可以想一下今天学到了什么和正在做的项目。而且我觉得也完全不用勉强自己写很多字数，只需要一个行动即可。 我每天学到的东西也不多，可能不足以为了这点东西来写一个博客，但是写一下自己的某些思考应该还是不错的，一天之内随便思考点什么东西，然后随便写点什么东西，差不多了。 总之还是加油吧 别的东西这学期又有好多麻烦的项目和任务。为什么说麻烦，因为我觉得自己的技术还只是学了点皮毛的程度，身边好多大佬对于这种项目想必是信手拈来的吧。正因为如此，还是要不断的学习和写代码才行。 首先是创新实践课，老师是网安方向的，为我们设置的方向都是网安相关，所以这学期还得学学网安，真的是从0开始学啊，不知道最后会怎么样，上学期创新实践还不是这样的 然后有一个Web应用程序设计的课，本来应该会分成.NET和Java语言两个课的，老师说由于Java版的课的一个老师因为学教评太低了，导致课开不了了，所以只有.NET开了。刚开始本来是就11个人选，后来发现另一个学院的这个课是必修，两个班凑在一起上，那就不会停课了。 其实我就是为了凑学分才选这个课的，相信很多人也是这样的。结果老师问有多少人本来要选那个没开的Java版的课的，大部分的人举手了，好像只有2个人举手本来就是选.NET。 最后就是这个课的上课方式修改了，老师说用什么语言随意，反正最后开发一个Web应用就完事了，但是还是有一些要求，现在还不太明确。","tags":["journal"],"categories":["日记"]},{"title":"PowerShell7的安装和简单使用","path":"/blog/2023-03-09-install-powershell/","content":"针对PowerShell7的简单安装和配置 PowerShell71.PowerShell简介 PowerShell全称 Windows Power Shell，是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以利用.NET Framework的强大功能来执行一些操作 之前使用WSL时针对Windows Terminal集成的默认的PowerShell进行了配置，默认的PowerShell也叫 Windows PowerShell 5.1 ，是在 .NET Framework v4.5 基础上构建的 但是现在的 PowerShell 7.x 也称为 **Powershell Core **，打开默认的PowerShell会打印微软的推荐： 尝试新的跨平台 PowerShell https://aka.ms/pscore6 听名字就知道它是基于跨平台且开源的.NET Core 构建的。因为跨平台，当然也可以在Linux上使用 2.安装PowerShell7现在最新的PowerShell7.3基于2022年11月8日发布的**.NET 7**，当然也可以选择下载LTS版本等 安装步骤 直接去github下载并安装release：PowerShell&#x2F;PowerShell: PowerShell for every system! (github.com) 安装界面的功能都可勾上 安装完成后，Windows Terminal就会自动集成PowerShell7，有了PowerShell7，Windows Terminal就可以选择使用PowerShell7为默认启动配置了 3.PowerShell的配置3.1 NF字体 首先还是需要有一个NF字体，因为默认字体不支持之后要配置的部分主题格式 若之前使用Windows Terminal时已经安装了NF字体就不需要下载了，以下网站中随便选一个字体下载安装： https://www.nerdfonts.com 然后使用管理员身份打开Windows Terminal，Ctrl+ shift+, 打开wt的settings.json 对其中的 profiles.defaults下 添加以下字体配置，face设置的就是刚刚下载的字体名，最后保存即可 1234567&quot;profiles&quot;: &#123; &quot;defaults&quot;: &#123; &quot;font&quot;: &#123; &quot;face&quot;: &quot;下载的字体名&quot; 3.2 安装Oh My Posh 和主题配置 Oh My Posh的已经不再支持PowerShell模块，因此不能再使用以下的方式安装 Install-Module oh-my-posh -Scope CurrentUser -SkipPublisherCheck 如果之前是这样安装的，需要参考Oh My Posh的迁移方案：https://ohmyposh.dev/docs/migrating 记得要删除之前的模块：Uninstall-Module oh-my-posh -AllVersions 以下使用winget方式安装 1winget install oh-my-posh 然后输入notepad $PROFILE打开PowerShell的配置文件，添加如下命令。重启后即可成功配置Oh My Posh 可在Oh My Posh的官方文档中选择主题：https://ohmyposh.dev/docs/themes 更换主题只需修改xxxx.omp.json即可 退出后重新进入，可见配置生效 1oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\\jandedobbeleer.omp.json&quot; | Invoke-Expression 3.3 模块安装 首先安装PSReadLine，用于命令自动提示 1Install-Module -Name PSReadLine -AllowPrerelease -Scope CurrentUser -Force -SkipPublisherCheck 然后安装文件图标库，显示文件时可显示文件的颜色以及图标 1Install-Module -Name Terminal-Icons -Repository PSGallery 接下来就要在PowerShell的启动前参数中配置 12345oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\\jandedobbeleer.omp.json&quot; | Invoke-Expression# 导入文件图标模块Import-Module -Name Terminal-Icons# 命令行提示Tab选择功能Set-PSReadlineKeyHandler -Key Tab -Function MenuComplete 此时即配置完成 如果觉得打开速度慢，可以不导入文件图标模块","tags":["PowerShell"],"categories":["PowerShell"]},{"title":"整理书签","path":"/blog/2023-03-07-journal/","content":"整理书签的思考 整理书签浏览器书签断断续续存了好多了，可能达到上千个了，以前的存放方式感觉不太行，所以要整理，然而整理就要花费很多时间了。 就是因为一开始如果没有做好书签的存放位置和层次，后面就得一个一个看过来，导致这个麻烦的发生。不过还有原因应该是平时保存的一些文章类型的书签没有及时消化掉，而是直接丢到了书签文件夹里去。 这个问题在b站视频的收藏中也存在，很多人说“收藏从未停止，学习从未开始”，一个视频觉得不错就把它收藏了但是没有去看，那和没有收藏没啥区别。我以前也是收藏了很多的b站视频，后来意识到了这个问题。 现在的做法就是遇到一个好的视频，但是当前没有时间去看，就可以直接添加到稍后观看里去，这样我就会经常想起来去看完这个视频，所以现在收藏视频变得越来越少了。 不过还是难免会遇到稍后观看也吃灰的问题。我觉得这个问题的底层可能跟拖延症有关，我自己也是喜欢拖延的人，这个习惯真的不好，会导致很多应该要做的事没有及时完成，然后导致后续要做的事不断错位。 这个要想改正也只能看自己了。整理书签也不能马上整理完，需要每天持续一点点地整理了。 有一个插件或许有点作用，这个插件能间隔一段时间随机找一个书签然后提示出来，让我对它进行处理。可能对整理书签有些帮助 温故知新 - Microsoft Edge Addons","tags":["journal"],"categories":["日记"]},{"title":"时间消耗、一周结束","path":"/blog/2023-03-06-journal/","content":"对于时间的消耗，以及上课一周结束的思考 时间消耗这个周末，说实话，摆烂了好多，然后又在折腾各种乱七八糟的东西，时间花费了很多。其实我觉得，折腾东西是挺有意思的，但是可能是有一个曲线在，后面如果一直没办法解决问题，就会感觉无聊，想放弃了。唉，自己解决问题的速度还是太慢了，也是自己太菜的原因吧，还是得更多的学习才行。 对于学校课程，我的计划是还要去学一些东西的，但是其实寒假以及返校考试的时间段时就摆烂了，看来我真的是一个喜欢浪费时间的人。而且，看到很多人能充分利用好碎片时间，我就发现了自己没有这个能力，有时候就是一小段时间，觉得反正就那么点时间，干脆就休息吧！于是就休息了。 然后还有一个就是晚上熬夜，我基本上都是1点后睡觉了，这个只能说可能是因为事情太多，或者有什么事没做完，就顺带熬夜了。熬夜确实不太好，希望以后能早点睡觉吧。 一周结束上课一周结束了，这周因为是第一周还不知道后面的险恶吧，还算轻松，也许比上学期会轻松点。这周完成的事不算多，代码也没怎么写。下周加油了","tags":["journal"],"categories":["日记"]},{"title":"WSL的安装和简单使用","path":"/blog/2023-03-05-install-and-simple-use--WSL/","content":"基于b站和各个网上教程的WSL安装使用简单记录 WSL的安装和简单使用 可直接查阅微软官方文档：安装 WSL | Microsoft Learn 1.安装WSL1.1 前置条件和说明 首先要确保电脑的CPU开启了虚拟化 同时需要win10版本为 1903 或更高版本，内部版本为 18362 或更高版本 以下要安装的是WSL2，并且不是安装预览版的方式，而是旧版的进行手动的安装 旧版 WSL 的手动安装步骤 | Microsoft Learn 1.2 安装步骤和查看安装步骤 打开powershell， 启用“适用于 Linux 的 Windows 子系统”可选功能 1dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 同时 启用“虚拟机平台”可选功能 1dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 然后重启电脑 下载并安装 Linux 内核更新包： WSL2 Linux Kernel update package for x64 machines 接下来运行以下命令，将 WSL 2 设置为默认版本 1wsl --set-default-version 2 安装Linux发行版，直接在Microsoft Store中搜索WSL即可找到几个Linux发行版，此处安装的是ubuntu20.04，直接点击安装即可。 打开刚刚安装的ubuntu，因为是第一次安装，会需要进行一些初始设置。 需要输入用户名和密码 至此即安装完成，可以直接点击ubuntu图标进行使用 查看安装完成后的系统 输入screenfetch即可查看到Linux版本 同时这个ubuntu已经预装了git和python等等，均可查看 在powershell中，通过命令：wsl -l -v，可以查看子系统的运行状态。 2.使用Windows Terminal2.1 Windows Terminal安装Windows Terminal是一个比较好用的终端工具，可以集成powershell、cmd、wsl等 在Microsoft Store中直接搜索Windows Terminal，即可下载安装 可见可直接在其中打开wsl 2.2 Windows Terminal的美化 首先直接在Microsoft Store搜索 on-my-posh下载并安装 设置字体 下载一个Nerd Font字体并安装：https://www.nerdfonts.com 然后使用管理员身份打开Windows Terminal，Ctrl+ shift+, 打开wt的settings.json 对其中的 profiles.defaults下 添加以下字体配置，face设置的就是刚刚下载的字体名，最后保存 1234567&quot;profiles&quot;: &#123; &quot;defaults&quot;: &#123; &quot;font&quot;: &#123; &quot;face&quot;: &quot;下载的字体名&quot; 配置主题 直接中wt中输入以下命令打开powershell配置文件 如果找不到配置文件，直接按照$PROFILE输出的路径和文件名，新建一个即可。 一般powershell的配置文件在用户的文档目录下的\\WindowsPowerShell文件夹下 1notepad $PROFILE 在打开的文件中写入以下代码，然后保存退出 1oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\\json.omp.json&quot; | Invoke-Expression 然后wt中输入下面的命令，使配置生效。至此主题配置完成 1.$PROFILE 当然也可以修改主题，通过以下命令可找到各种主题，复制想要更换的主题名，重新打开powershell配置文件修改xxx.omp.json，xxx就是新的主题名，然后保存退出重复上一个步骤并重启即可 1Get-PoshThemes 3.为WSL配置zsh相比于默认的 Bash，zsh 有更多的自定义选项；然后oh-my-zsh是一个流行的 zsh 配置，可以自动配置zsh 首先安装zsh 1sudo apt install zsh 安装ohmyzsh，根据提示安装即可 1sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 如果无法访问到github，可进行如下操作： 在 https://site.ip138.com/raw.Githubusercontent.com/输入raw.githubusercontent.com查询IP地址 然后使用code /etc/hosts 修改hosts，添加刚刚的ip映射 使用ls -la可见zsh的配置文件.zshrc，可对zsh配置插件和主题，可查看ohmyzsh的wiki进行配置 比如以下安装一个ash-autosuggestions，cd进入.oh-my-zsh的plugin文件夹直接git clone对应的仓库即可 然后对 .zshrc修改，增加插件的名称即可 1234plugins=(\tgit\tzsh-autosuggestions) 这个插件可以根据历史记录和完成提示键入的命令 实现效果： 4.使用VSCode配合WSL编写代码 打开vscode后，可见其自动提示安装WSL相关插件，直接安装：Remote Development 在wt的wsl中创建一个目录，然后cd进入此目录 12mkdir WSLCodeDemocd WSLCodeDemo 此时使用以下命令试图通过vscode打开目录，可见其会自动安装 VS Code Server。接下来vscode就成功打开此目录了 同时安装插件后，可在远程资源管理器中直接打开WSL的文件目录，可以直接下载和上传文件 1code . 此时，在vscode中新建文件，就是在WSL中新建文件。即此时可在windows中通过vscode编辑和处理WSL内部的文件了。因为WSL默认安装了Python3，以下模拟编写Python 此时新建一个test.py，vscode会提示安装python插件，并在WSL上启用插件。此时写入简单程序 注意这里运行的vscode的插件分为本地和远程插件，可以在WSL上安装插件 1print(&#x27;Hello world!&#x27;) 然后vscode中直接运行程序，可见在wsl中成功输出了Hello world! 此时，就实现了在Windows中编写代码，而在Linux中直接运行的效果 5.文件的互相访问5.1 Windows访问WSL中的文件①使用vscode访问WSL中的文件 还是使用code命令，比如在WSL的根目录中输入命令，即可在vscode中查看到WSL根目录下的所有文件 同时vscode的远程资源管理器也可打开并访问文件 1code . ②使用Windows的资源管理器 可直接在我的电脑中查看并打开WSL的文件目录进行访问 同时也可以直接在WSL中输入命令使用资源管理器打开当前的目录 1explorer.exe . ③使用SSH连接 这和Linux中安装ssh服务，然后进行连接类似了 5.2 WSL访问Windows的文件 在WSL根目录下有一个mnt目录，进入此处可看到windows的每个盘了 123cd /mnt/ccd /mnt/dcd /mnt/e 此时可见windows中的文件，可用命令进行操作 6.WSLg 全称Windows Subsystem for Linux GUI WSLg是图形化的WSL，能够完成Ubuntu一小部分的图形显示，即可以运行WSL中的GUI程序，比如gedit WSLg本来只在win11上支持，但是win10的22H2版本也支持WSLg 如下打开gedit： 安装步骤 如果电脑是win11，或者是win10 22H2版本，可以使用。win10低版本首先需要更新系统升级到22H2 然后更新WSL 1wsl --update 更新完成后检查WSL的版本，能够正常显示，说明安装成功 1wsl --version 显示结果： WSL 版本： 1.1.3.0 内核版本： 5.15.90.1 WSLg 版本： 1.0.49 那么此时就可以愉快地使用WSLg了 比如安装gedit并使用gedit命令使用，安装后同时也可直接在windows开始目录下找到安装在WSL中的程序，点击也可直接运行 123sudo apt install gedit -ygedit 总的来说，有了WSLg后，WSL就更好用了，用起来的感觉挺神奇","tags":["vscode","Linux"],"categories":["Linux"]},{"title":"使用vscode编写C#代码","path":"/blog/2023-03-03-write-csharp-with-vscode/","content":"针对vscode如何编写C#代码进行了简单配置 使用vscode编写C#代码1.环境准备 在cmd或powershell中输入以下命令可查看电脑是否安装了.NET的相关SDK，以及查看版本 1dotnet --info 目前最新.NET版本是7 如果没有，则去微软官网进行下载并安装：下载 .NET(Linux、macOS 和 Windows) (microsoft.com) 安装步骤是无脑下一步 此时再输入上述命令，成功查看到.NET版本，即安装成功 2.vscode插件安装1、C# 装这个就能做大部分事了 2、vscode-solution-explorer 可自动生成解决方案和项目，不用输命令 3、C# XML Documentation 用于&#x2F;&#x2F;&#x2F;自动生成文档注释 4、.NET Core Add Reference 用于在项目上直接右键添加引用 5、Add Local .Net Reference 用于添加本地程序集引用 6、ASP.NET Core Switcher MVC项目时，可直接在视图和控制器之间切换 7、C# Extensions 用于右键自动添加C#类、接口、MVCController等 以上插件基本够用了，别的之后按需获取即可 3.创建一个项目 首先在Solution Explorer中选择Create New Solution，然后输入FirstDemo。可见创建了sln解决方案文件 然后在Solution Explorer中对解决方案右键——Add New Project，即可为当前解决方案添加项目 这里选择控制台应用程序，语言选择C#，然后对项目的命名，可以和解决方案同名，回车即可创建成功 打开项目下的Program.cs文件，vscode右下角会弹出创建launch和tasks文件的选项，点击yes即可。如果不创建将无法调试 此时生成的Program.cs如下，这是C#使用了顶级语句 12// See https://aka.ms/new-console-template for more informationConsole.WriteLine(&quot;Hello, World!&quot;); 不用顶级语句将会创建如下 123456789101112using System;namespace FirstDemo // Note: actual namespace depends on the project name.&#123; internal class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;Hello World!&quot;); &#125; &#125;&#125; 点击调试，即可成功运行输出“Hello World!”，说明成功","tags":["C#","vscode"],"categories":["DOTNET"]},{"title":"C#基础语法速成","path":"/blog/2023-03-02-CSharp-Basic-Grammar/","content":"这学期突然要学C#，那就学吧。以下笔记仅作自用 C#基础语法速成1.C#基本认识和特点 C#是微软公司发布的一种面向对象的、运行于 .NET Framework 和 .NET Core (完全开源，跨平台）之上的高级程序设计语言。 C#是一种安全的、稳定的、简单的、优雅的，由C和C++衍生出来的面向对象的编程语言。它在继承C和C++强大功能的同时去掉了一些它们的复杂特性。 C#是面向对象的编程语言。 C#可以用指针，但是不推荐也少用了 .NET和C#关系 .NET是C#运行环境，C#是开发语言， C# 可以编写在.NET 中运行的应用程序。 .NET公共语言运行时 (CLR) 是生成所有.NET 应用的基础，这个运行时还支持多种语言，有 C#、F# 和 Visual Basic 语言，但是C#算是主角 2.Visual Studio的安装和使用 Microsoft Visual Studio（简称VS)是美国微软公司的开发工具包系列产品VS是一个基本完整的开发工具集，是编写C＃程序或者说NET程序最常用的开发工具。 下载vs网址：https://visualstudio.microsoft.com/zh-hans/downloads/ vsi工作负载，根据自己的情况选择需要的安装模块，一般选择：ASP.NET和Web开发、.NET桌面开发、通用Windows平台开发、数据库存储和处理、Visual Studio扩展开发、.NET Core跨平台开发 2.1 开始第一个项目 就不创建控制台程序了，直接创建一个windows窗体应用，就不搞控制台应用了 选择C#、Windows、桌面，找到 WPF 应用(.NET Framwork) 2.2 VS的结构 一般习惯工具箱和解决方案资源管理器放在左边 别的好像也没啥了，随意了 3.cs文件结构 上面程序的各个部分： using System： using 关键字：用于在程序中包含System命名空间。一个程序一般有多个using语句。 namespace声明：一个namespace是一系列的类。WebApplication1命名空间 包含了类Program。 class声明：类Program包含了程序使用的数据和方法声明。类一般包含多个方法，方法定义了类的行为。类只有一个Main方法。 Main方法：是所有C#程序的入口点。Main方法说明当执行时类将做什么动作。 Main方法通过方法体中的语句指定它的行为。 以下几点值得注意： 一个cs文件的结构大约是由以上几个部分组成，但是根据不同的需求和作用，会有不同的内容 程序的执行从Main方法开始 4.C#基本语法 C#是一种面向对象的编程语言。在面向对象的程序设计方法中，程序由各种对象组成。相同种类的对象通常具有相同的类型。 C#是大小写敏感的 所有的语句和表达式必须以分号 ; 结尾 与Java不同的是，文件名可以不同于类的名称 4.1 关键字关键字，是对编译器有特殊意义的预定义保留标示符，它们不能在程序中用作标示符 using关键字 using关键字用于在程序中包含命名空间。一个程序可以包含多个using语句。 在任何C＃程序中的第一条语句都是： 1using System; class关键字 class关键字用于声明一个类。 4.2 注释 块注释 123/*这个程序演示C#语言的多行注释语法*/ 单行注释是用//符号表示。 1// test 文档注释用///符号表示 应用场合：声明的方法、类上 123456/// &lt;summary&gt;/// 这是主程序入口/// &lt;/summary&gt;/// &lt;param name=&quot;args&quot;&gt;需要传入的参数&lt;/param&gt;public static void Main(string[] args)&#123;&#125; 注释的作用： 解释：说明代码作用 注销：将暂时不需要的代码注销 总结： 不写注释是流氓 名字瞎起是扯淡 相比注销，注释意义更大 要做到别人一看就能看懂 4.3 变量 在C#中，每个变量都有一个特定的类型，不同类型的变量其内存大小也不尽相同。 C#的基本类型： 类型 举例 整数类型 byte(0-255)、short(-32768-32767)、int(-2*10^9-2*10^9)、long 浮点型 float、double 十进制类型 decimal 布尔类型 bool 字符类型 string、char 空类型 null float浮点类型，小数后需带f&#x2F;F decimal相当于精度更大的浮点型，但会有更多的性能损耗 浮点型之间的转换只有float转换为double一种，decimal无法直接转换到浮点型 5.C#语法进阶5.1 表达式 表达式由操作数(operand)和运算符(operator)构成。运算符的示例包括 ＋、- 、*、／ 和 new。操作数的示例包括文本、字段、局部变量和表达式。 当表达式包含多个运算符时，运算符的优先级(precedence)控制各运算符的计算顺序。例如，表达式x+y*z按x + (y * z)计算，因为＊运算符的优先级高于＋运算符。 （了解）大多数运算符都可以重载(overload,)。运算符重载允许指定用户定义的运算符实现来执行运算这些运算的操作数中至少有一个，甚至所有操作数都属于用户定义的类类型或结构类型。 下表总结了C#简单常用的运算符，并按优先级从高到低的顺序列出各运算符类别。同一类别中的 运算符优先级相同。 类别 表达式 说明 基本 x.m 成员访问 x(…) 方法和委托调用 x[…] 数组和索引器访问 new T(…) 对象和委托创建 new T(…){…} 使用初始值设定项创建对象 new {…} 匿名对象初始值设定项 new T[…] 数组创建 类别 表达式 说明 一元 +x 恒等 -x 求相反数 !x 逻辑求反 ~x 按位求反 ++x 前增量 –x 前减量 x++ 后增量 x– 后减量 (T)x 将x显式转换为类型T 类别 表达式 说明 二元 x*y、x&#x2F;y、x%y、x+y、x-y 乘除余加减（加号还有字符串串联） x&lt;&lt;y、x&gt;&gt;y 位左移、位右移 x&lt;y、x&gt;y、x&lt;&#x3D;y、x&gt;&#x3D;y 小于、大于、小于等于、大于等于 x is T 如果x为类型T，则返回 true，否则返回false x as T 返回转换为类型T的x，如果x不是T则返回null x&#x3D;&#x3D;y、x!&#x3D;y 等于、不等于 x&amp;y、x|y 整型按位AND&#x2F;OR，布尔逻辑AND&#x2F;OR x &amp;&amp; y 仅当x为true时，才对y求值 x ?? y 如果x为null，则计算结果为y，否则计算结果为x 类别 表达式 说明 三元 x?y:z 如果x为true，则对y求值；反之对z求值 x&#x3D;y 赋值 x&#x3D;x+y 复合赋值 (T x)&#x3D;&gt;y 匿名函数（lambda表达式） 5.2 分支语句if语句 1234567if(i&gt;1)&#123;&#125;else if(i&gt;2)&#123; &#125;else&#123; &#125; switch语句 12345678switch (i) &#123; case 1: Console.WriteLine(&#x27;1&#x27;); break; default: Console.WriteLine(&#x27;2&#x27;); break;&#125; for循环 123for (int k = 0; k &lt; 10; k++) &#123; Console.WriteLine(k);&#125; while循环 123456789int i3 = 0;while (true) &#123; i3++; if (i3 == 3) break;&#125;do &#123; Console.WriteLine(&#x27;1&#x27;);&#125; while (true); 这些看看就好了 5.3 数组 数组是一组相同类型的数据。 数组中的数据需要通过数字索引来访问。 数组的声明 数组的声明需要使用new关键字。 在声明数组时，可以使用｛｝来初始化数组中的元素。 如果在数组声明之初没有使用大括号来初始化数组中的元素，则需要指定数组的大小。 在声明初始化有元素的数组时，也可以指定数组大小。 12345678// 声明没有元素的数组int[] arr1 = new int[6];// 声明初始化有元素的数组int[] arr2 = new int[6] &#123; 1, 2, 3, 4, 5, 6 &#125;;// 在声明初始化有元素的数组时，也可以指定数组大小string[] strings = new string[3] &#123; &quot;1&quot;, &quot;2&quot;, &quot;3&quot; &#125;;// 不指定大小声明数组int[] arr3 = &#123; 1, 2, 3 &#125;; 通过索引获取数组中的元素 给数组指定长度时，数组准备存放多少元素，长度就设置为多少 用索引获取数组内的元素时，索引从0开始获取。 所以数组中最大的索引数字，比指定数组长度小1。 这些看看就好了 5.4 类型转换 (int)表示使用显式强制转换，是一种类型转换，C#默认整型是int32，因此使用此方法转成int32位，不遵循四舍五入，于是只截取到了整数部分 (int)5.21 &#x2F;&#x2F;输出5 ①int.Parse()：只支持将string类型转成int，Parse就是把String类型转换成int、char、double等 也就是*.Parse(string)括号中的一定要是string类型。 1234String st = &quot;5.21&quot;;double n = 5.21;int.Parse(st); //输出5int.Parse(n); //报错 ②Convert.Tolnt32(double value)：不完全遵循四舍五入，如果value为两个整数中间的数字，则返回二者中的偶数 注意： Convert.Tolnt32() 和 int.Parset() 对于空值(null)的处理不同，Convert.Tolnt32(nul)会返回0而不会产生任何异常，但int.Parse(null)则会产生异常 123456Console.WriteLine(Convert.ToInt32(4.3));//四舍五入，输出4Console.WriteLine(Convert.ToInt32(4.5));//第一位小数为5时，4.5在4和5之间，输出偶数4Console.WriteLine(Convert.ToInt32(4.53));//四舍五入，输出5Console.WriteLine(Convert.ToInt32(5.3));//四舍五入，输出5Console.WriteLine(Convert.ToInt32(5.5));//第一位小数为5时，5.5在5和6之间，输出偶数6Console.WriteLine(Convert.ToInt32(5.53));//四舍五入，输出6 5.5 函数 函数好比是对象的动作行为。 在定义函数要想好函数所承担的作用，职责（作用）越单一越好。 函数命名规范 函数命名使用大驼峰命名，即开头首字母大写 多个单词拼接时，所有单词首字母大写 123Add();AddCount();GetUserInfo(); 函数的参数设置&amp;传参行为&amp;返回值 参数可认为是外部需要函数帮忙处理的数据。 外部通过传递参数的形式，将需要处理的数据交给函数处理。 函数返回值可以认为是外部调用某种行为后得到的一种反馈。 12345678910/// &lt;summary&gt;/// 加法方法/// &lt;/summary&gt;/// &lt;param name=&quot;firstCount&quot;&gt;数字1&lt;/param&gt;/// &lt;param name=&quot;secondCount&quot;&gt;数字2&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public int Add(int firstCount, int secondCount) &#123; int total = firstCount + secondCount; return total;&#125; 5.5.1 参数修饰符①无修饰符：如果一个参数没有用参数修饰符标记，则认为它将按值进行传递，这将意味着被调用的方法收到原始数据的一份副本。 即上端调用方法后，下端修改传来的参数不会对原数据造成影响，即参数在方法中只复制了副本。 示例：方法不对原字符串影响修改 123456789string str1 = &quot;test1&quot;;SendMessage(str1);void SendMessage(string msg) &#123; msg = &quot;change&quot;; Console.WriteLine(msg); // change&#125;Console.WriteLine(str1); // test1 ②out：输出参数由被调用的方法赋值，因此按引用传递，如果被调用的方法没有给输出参数赋值，就会出现编译错误。 方法中out修饰的参数，一定要在方法内得到赋值 调用者可不赋初值，甚至可直接将声明变量写在方法调用传参中 即上下端的参数指向同一个地址，修改都会受到影响。 out最大的用途就是调用者只使用一次方法的调用就能获得多个返回值。 在C#7.0中要实现一次方法的调用就能获得多个返回值，建议使用元组。 示例： 1234567891011121314151617181920/* 1.方法中的修改作用到原字符串 */string str1 = &quot;test1&quot;;SendMessage(out str1);void SendMessage(out string msg) &#123; msg = &quot;change&quot;; Console.WriteLine(msg); // change&#125;Console.WriteLine(str1); // change/* 2.调用方法返回多个返回值 */// 这里直接在方法调用的out参数上声明变量string res = SellHouse(100, 1000, out string wantPrice);Console.WriteLine(res);Console.WriteLine(wantPrice);string SellHouse(int area, int price, out string wantPrice) &#123; wantPrice = &quot;出价&quot; + (area * price - 1); return &quot;张三买房&quot;;&#125; ③ref：调用者必须赋初值，并且可以由被调用的方法可选的重新赋值（数据是按引用传递的）。如果被调用的方法未能给ref参数赋值，也不会有编译器错误。 方法中ref修饰的参数，方法内未得到赋值不报错，和out不同。 但是调用者必须赋初值，否则报错。 示例： 12345678string str1 = &quot;test&quot;;//string str1; 报错SendMessage(ref str1);void SendMessage(ref string msg) &#123; msg = &quot;test2&quot;; Console.WriteLine(msg); // test&#125;Console.WriteLine(str1); // test ④params：这个参数修饰符允许将一组可变的数量的参数作为单独的逻辑参数进行传递，方法只能有一个params修饰符，而且必须是方法的最后一个参数。（就是可变参数） 总结out和ref的区别 out修饰的参数必须在方法内修改，而ref可以修改也可以不修改 out在传入参数的时候，参数是局部变量的话，可以不用赋值，因为out一定会对其进行赋值 out参数方法中必须赋值，所以可不需要初始值 而ref修饰的参数，在实参必须有初始值才能调用。因为ref修饰的不一定会给它赋值 因为方法中不一定给ref参数赋值，所以一定要有初始值 out修饰参数可在调用方法时直接声明变量，ref则不行 6.面向对象编程（OOP）6.1 面向对象编程基本概念 面向对象编程一一Object Oriented Programming简写OOP 之前所接触到的编程方式叫做面向过程 面向过程和面向对象是两种不同的编程方式 对比面向过程的特点，可以更好的了解什么是面向对象 过程和函数 过程是早期的一个编程概念 过程类似于函数，只能执行，但是没有返回值 函数不仅能执行，还可以返回结果 面向过程——强调怎么做？ 把完成某一个需求的所有步骤从头到尾逐步实现 根据开发需求，将某些功能独立的代码封装成一个又一个函数 最后完成的代码，就是顺序的调用不同的函数 特点： 注重步骤与过程，不注重职责分工 如果需求复杂，代码会变得很复杂 复杂项目，没有固定的套路，难度很大 比如一个主函数，自顶向下调用多个子函数，这几个子函数又会去调用多个子子函数，形成树的结构 面向对象逻辑——强调谁来做？ 相比较函数，面向对象是更大的封装，根据职责，在一个对象中封装多个方法 在完成某一个需求前，首先确定职责，要做的事情（方法） 根据职责确定不同的对象，在对象内部封装不同的方法（多个） 最后完成代码，就是顺序的让不同的对象调用不同的方法 特点： 注重对象和职责，不同的对象承担不同的职责 更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供固定套路 需要在面向过程基础上，再学习一些面向对象的语法 6.2 类和对象概念 类和对象是面向对象编程的两个核心概念 类是对一群具有相同特征或者行为的事物的一个统称，是抽象的，不能直接使用 特征被称为属性 行为被称为方法 例如：类相当于制汽车是的图纸，是一个模板，是负责创建对象的 对象 对象是由类创造出来的一个具体存在，可以直接使用 由哪一个类创造出来的对象，就拥有在哪一个类中定义的属性和方法 对象就相当于用图纸制造的汽车 先有类，再有对象 类和对象的关系 类是模板，对象是根据类这个模板创建出来的，应该先有类，再有对象 类只有一个，而对象可以有很多个 不同的对象之间属性的具体内容可能各不相同 类中定义了什么属性和方法，对象中就有什么属性和方法，不可能多，也不可能少 6.3 类的设计 在使用面向对象开发前，应该首先分析需求，确定一下程序中需要包含哪些类 在程序开发中要设计一个类，通常需要满足以下三个要素： 1.类名这类事物的名称，满足大驼峰命名法 2.属性这类事物具有什么样的特征 3.方法这类事物具有什么样的行为 类名的确定 名词提炼法分析整个业务流程，出现的名词，通常就是找到的类。 属性和方法的确定 对对象的特征，描述通常可以定义成属性。 对象具有的行为通常可以定义为方法。注：方法一般是动作即动词 提示：需求没有涉及的属性或者方法在设计类时，不需要考虑，即可忽略。 6.4 类和对象的使用6.4.1 声明类 声明一个类需要使用class关键字 类的属性及方法写在&#123;&#125;中 步骤：vs中右键项目名——添加——类 123public class Person &#123; &#125; 6.4.2 声明属性 属性在C#中较为独特，它既不同于方法，也不同于字段。 属性依旧遵循大驼峰命名法 属性最常用的书写方法：public int Age &#123;get; set;&#125; 如果属性中具有get关键字，说明可以获取该属性的值。 如果属性中具有set关键字，说明可以向该属性设置值。 如果没有get和set关键字，则无法获取属性值以及设置属性值 1234567namespace Csharp_Class &#123; public class Person &#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public int Height &#123; get; set; &#125; &#125;&#125; vs快捷编码 - 自动属性模板：输入props，按2次Tab，自动生成一个属性声明的模板 6.4.3 声明方法 详见函数初识 1234567891011121314namespace Csharp_Class &#123; public class Person &#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public int Height &#123; get; set; &#125; public void Eat() &#123; MessageBox.Show(&quot;吃&quot;); &#125; public void Run() &#123; MessageBox.Show(&quot;跑&quot;); &#125; &#125;&#125; 6.4.4 实例化 类使用关键字new实例化对象。 一个类可以实例化多个对象。 对象可以使用类定义的属性和方法。 1234567891011121314151617/* 在另一个类中实例化前面的类，并使用 */namespace Csharp_Class &#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void Form1_Load(object sender, EventArgs e) &#123; Person p = new Person(); p.Name = &quot;zhangsan&quot;; p.Age = 29; p.Eat(); p.Run(); &#125; &#125;&#125; 6.4.5 对象初始化器 在实例化之时，就对其属性进行赋值。 即实例化后直接跟随一个大括号，其中写明属性的赋值，注意这之中分隔符为逗号 可以不带括号了，直接连接大括号 12345678910111213141516/* 在另一个类中实例化前面的类，并使用 */namespace Csharp_Class &#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void Form1_Load(object sender, EventArgs e) &#123; // 拓展：对象初始化器：在实例化之时，就对其属性进行赋值 Person p2 = new Person() &#123; Age = 18, Name = &quot;zhangsan&quot; &#125;; &#125; &#125;&#125; 6.4.6 访问修饰符 public：公有的所有的类都可以访问 private：私有的当前类内部可访问 protected：受保护的当前类以及继承他的子类可访问 internal：内部的只限于本项目内访问，其他的不能访问。 protected internal：内部保护访问只能是本项目内部或子类访问其他类不能访问 访问级别约束： 父类子类访问修饰符要保持一致 方法的访问修饰符 要和 方法参数的访问修饰符 保持一致 注意：类的访问级别 默认为隐式私有，因此需要加上public才可让外部访问 6.4.7 static 静态方法、属性 静态属性和方法 通过**static关键字**修饰 静态属性和方法 可以通过类型直接获取，非静态则必须通过实例化的对象获取 静态类 静态类通过**static关键字**修饰 一般情况下类型不需要使用静态修饰，只有当类型中存在扩展方法时需要使用静态类 7.集合&amp;字典的使用7.1 集合的使用 集合与数组比较类似，都用于存放一组值 7.1.1 数组的优劣分析优势 数组在内存中是连续存储的，所以它的索引速度是非常的快，而且赋值与修改元素也很简单。 劣势 在数组的两个数据间插入数据很麻烦 在声明数组的时候，必须同时指明数组的长度，数组的长度过长，会造成内存浪费，数组和长度过短，会造成数据溢出的错误 7.1.2 ArrayList的使用 ArrayList是 .NET Framework 提供的用于数据存储和检索的专用类 它是命名空间 System.Collections下的一部分 ArrayList的优势 ArrayList的大小是按照其中存储的数据来动态扩充与收缩的 在声明 ArrayList 对象时并不需要指定它的长度 ArrayList可以很方便的进行数据的添加，插入和移除 123456ArrayList arrayList = new ArrayList();arrayList.Add(123);arrayList.Add(&quot;abc&quot;);arrayList.Insert(1, 123 + &quot;abc&quot;);arrayList.RemoveAt(0);arrayList.Remove(&quot;abc&quot;); 从上面示例看，ArrayList好像是解决了数组中所有的缺点，那么它应该就是完美的。 可是在C#2.0 后又出现了List集合，这是为何？ ArrayList的劣势 ArrayList在存储数据时时是使用 object类型 进行存储的 object是所有类的父类（父类可接收子类的对象） ArrayList不是类型安全的，使用时很可能会出现类型不匹配的错误 就算都有插入了统一类型的数据，但在使用的时候，也需要将它们从object转化为对应的原类型来处理 ArrayList的存储存在 装箱 和 拆箱 操作，导致其性能低下 7.1.3 装箱与拆箱的概念 装箱：将比如int类型或者string等 不同类型的对象 通过 隐式转换 赋给object对象。（子赋给父） 12int i = 123;object o = i; 拆箱：将 object对象 通过显式转换 赋给int类型的变量（父转换为子） 显式转换的前提是，被转换者的类型确实是这个类型。否则报错 12object o = 123;int i = (int)o; 装箱与拆箱的过程会产生较多的性能损耗。 正是因为ArrayList存在 不安全类型 与 装箱拆箱 的缺点，所以在C#2.0后出现了泛型的概念。 泛型的概念在此先不多做表述，可以简单理解成：限制集合只能够存储单一类型数据的一种手段 7.1.4 List集合 目前只学习List集合这一种类型即可，以此为突破口，以后再学习其他集合就会非常容易 List集合的声明 List集合与ArrayList由于都继承成了相同的接口，故使用与ArrayList相似。 在声明List集合时，需要同时为其声明List集合内数据的对象类型 示例：List&lt;int&gt; intList = new List&lt;int&gt;() 接口：限制和规定类型行为即类型方法的一种手段。 12345678910111213List&lt;int&gt; ints = new List&lt;int&gt;();ints.Add(1);//ints.Add(&quot;abc&quot;);ints[0] = 2;ints[1] = 3;ints.Insert(0, 5);ints.RemoveAt(0);ints.Remove(2);// 对象初始化器方式List&lt;int&gt; ints2 = new List&lt;int&gt; &#123; 1,2,3,4,5&#125;;ints2.Clear(); 上例中，如果往List集合中插入string字符串”abc”，系统就会报错，且不能通过编译。这样就避免了前面讲的类型安全问题与装箱拆箱的性能问题 在List集合中使用自己创建的类 12345678910111213141516171819202122internal class Person &#123; public int Age &#123; get; set; &#125; public string Name &#123; get; set; &#125; public int Height &#123; get; set; &#125;&#125;List&lt;Person&gt; people = new List&lt;Person&gt;();Person person1 = new Person &#123; Age = 18, Height = 178, Name = &quot;张三&quot;&#125;;people.Add(person1);people.Add(person1);people.Add(new Person &#123; Age = 18, Height = 178, Name = &quot;张三&quot;&#125;);Person person2 = people[0];people.RemoveAt(0);people.Remove(person1); 注意remove方法删除的是指定地址的对象，而每次new出来的对象即使属性相同但是地址不同，还是不同的对象，那么就不能同时被删除掉 总结 集合与数组比较类似，都用于存放一组值 集合中提供了特定的方法能直接操作集合中的数据，并提供了不同的集合类来实现特定的功能 简单的说就是数组的升级版。 他可以动态的对集合的长度（也就是集合内最大元素的个数）进行定义和维护 List泛型的好处指通过允许指定 泛型类或方法 操作的 特定类型， 减少了类型 强制转换 的需要和运行时错误的可能性，泛型提供了类型安全，但没有增加开销。（不会发生装箱和拆箱） 7.2 字典的使用 即一个萝卜一个坑，每一个标记有不重复编号的坑都只能放一个萝卜或者其它东西 Dictionary有 key(键) 和 value(值)，一个键只能对应一种值 一个value可以有很多key，但是key是唯一的。 比如学生是唯一的，成绩不唯一 总结：键唯一，值不唯一 Dictionary声明 在声明Dictionary字典时，需要同时为其声明Dictionary字典内键与值的类型。 示例：Dictionary&lt;int,string&gt; dictionary = new Dictionary&lt;int, string&gt;() 123456789101112131415Dictionary&lt;int, string&gt; dictionary = new Dictionary&lt;int, string&gt;();// 方式一：Add方法赋值dictionary.Add(1, &quot;98分&quot;);dictionary.Add(2, &quot;92分&quot;);dictionary.Add(3, &quot;89分&quot;);dictionary.Add(1, &quot;88分&quot;); // 运行后系统会报错（重复键）// 方式二：索引器赋值dictionary[1] = &quot;88分&quot;; //系统不报错dictionary[4] = &quot;99分&quot;;// 方式三：对象初始化器Dictionary&lt;string, string&gt; dictionary2 = new Dictionary&lt;string, string&gt; &#123; &#123; &quot;A&quot;, &quot;aa&quot; &#125;, &#123; &quot;B&quot;, &quot;bb&quot; &#125;, &#123; &quot;C&quot;, &quot;cc&quot; &#125;&#125;; Dictionary取值和删除 Dictionary索引器中写的键，获取到的是单个的对应值 1234567891011//获取键为1的值// 方式一：索引器取值string value = dictionary[1];// 方式二：foreach遍历取值（这里遍历项就是每一个小键值对，用KeyValuePair专门定义可设置或检索的键值对）foreach (KeyValuePair&lt;int, string&gt; item in dictionary) &#123; string value2 = item.Value;&#125;// 移除键为1的键值对dictionary.Remove(1); 总结 键与值可以是任何类型， 但是键必须在设置时是唯一的， 而值可以不唯一 使用Add(）方法添加键值对，不可添加已有的键名 索引模式可以 新赋值 也可以 修改 已有的键值（注意不是下标） 字典是键值对的集合 7.3 foreach使用 foreach就是传说中的增强for循环或者称作foreach循环 foreach对遍历字典或集合具备天然优势， 效率高过for循环 它循环的对象继承了迭代器 foreach操作数组 12345int[] ints = &#123; 1,2,3,4 &#125;;foreach (int item in ints) &#123; // 每次循环，其item都是整型数组中的一个元素 MessageBox.Show(item.ToString());&#125; foreach操作集合 12345List&lt;int&gt; intList = new List&lt;int&gt; &#123; 1,2,3,4 &#125;;foreach (int item in intList) &#123; // 每次循环，其item都是List集合中的一个元素 MessageBox.Show(item.ToString());&#125; foreach操作字典 这里的item就是一个小键值对 1234foreach (KeyValuePair&lt;int, string&gt; item in dictionary) &#123; int key0 = item.Key; string value0 = item.Value;&#125; 使用var类型推断 var关键字的作用是推断类型，声明的时候必须赋值。赋值到什么类型就成为什么类型 12345List&lt;int&gt; listInt = new List&lt;int&gt; &#123; 1, 2, 3, 4 &#125;;foreach (var item in listInt)&#123; Console.WriteLine(item);&#125; 那么至此C#大概常用的简单语法就学完了","tags":["C#"],"categories":["DOTNET"]},{"title":"开始","path":"/blog/2023-02-28-start/","content":"从博客的博客的博客中看到了以下内容，我觉得确实，随便写点东西也会有用的。 日记的作用作者链接: 对6年日记|的观察ᕕ( ᐛ )ᕗ 赫尔曼的博客 (bearblog.dev) 编程有一个术语叫做”橡皮鸭”，指的是这样一种场景: 程序员遇到一个特别困难的问题，有时会找到其他人，向他人描述这个问题，希望其他人给点建议。 但是，在描述问题时，为了让他人理解，程序员会逐渐理清思路，有时还没等其他人给出建议，自己就悟到应该怎么解决了。 这样的场景中，其他人的作用完全可以用一个橡皮鸭代替。如果遇到想不清楚的问题，就可以尝试对着一只橡皮鸭来解释这个问题，想象怎么描述，可以让橡皮鸭理解这个问题。 在某些方面，作者觉得，日记就是他的橡皮鸭。 在日记里面描述那些困难的问题，可以帮助理清思路，构建想法，反思自己的做法和情绪，并锻炼自己更好的表达能力。 他说他已经坚持写日记六七年。","tags":["journal"],"categories":["日记"]},{"path":"/about/index.html","content":"关于本站本站就是一个普通的博客网站，没啥东西。就目前个人而言，还啥都不会"},{"title":"便笺","path":"/notes/index.html","content":"TOC便笺"}]