[{"title":"PowerShell7的安装和简单使用","path":"/blog/2023-03-09-install-powershell/","content":"针对PowerShell7的简单安装和配置 PowerShell71.PowerShell简介 PowerShell全称 Windows Power Shell，是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以利用.NET Framework的强大功能来执行一些操作 之前使用WSL时针对Windows Terminal集成的默认的PowerShell进行了配置，默认的PowerShell也叫 Windows PowerShell 5.1 ，是在 .NET Framework v4.5 基础上构建的 但是现在的 PowerShell 7.x 也称为 **Powershell Core **，打开默认的PowerShell会打印微软的推荐： 尝试新的跨平台 PowerShell https://aka.ms/pscore6 听名字就知道它是基于跨平台且开源的.NET Core 构建的。因为跨平台，当然也可以在Linux上使用 2.安装PowerShell7现在最新的PowerShell7.3基于2022年11月8日发布的**.NET 7**，当然也可以选择下载LTS版本等 安装步骤 直接去github下载并安装release：PowerShell&#x2F;PowerShell: PowerShell for every system! (github.com) 安装界面的功能都可勾上 安装完成后，Windows Terminal就会自动集成PowerShell7，有了PowerShell7，Windows Terminal就可以选择使用PowerShell7为默认启动配置了 3.PowerShell的配置3.1 NF字体 首先还是需要有一个NF字体，因为默认字体不支持之后要配置的部分主题格式 若之前使用Windows Terminal时已经安装了NF字体就不需要下载了，以下网站中随便选一个字体下载安装： https://www.nerdfonts.com 然后使用管理员身份打开Windows Terminal，Ctrl+ shift+, 打开wt的settings.json 对其中的 profiles.defaults下 添加以下字体配置，face设置的就是刚刚下载的字体名，最后保存即可 1234567&quot;profiles&quot;: &#123; &quot;defaults&quot;: &#123; &quot;font&quot;: &#123; &quot;face&quot;: &quot;下载的字体名&quot; 3.2 安装Oh My Posh 和主题配置 Oh My Posh的已经不再支持PowerShell模块，因此不能再使用以下的方式安装 Install-Module oh-my-posh -Scope CurrentUser -SkipPublisherCheck 如果之前是这样安装的，需要参考Oh My Posh的迁移方案：https://ohmyposh.dev/docs/migrating 记得要删除之前的模块：Uninstall-Module oh-my-posh -AllVersions 以下使用winget方式安装 1winget install oh-my-posh 然后输入notepad $PROFILE打开PowerShell的配置文件，添加如下命令。重启后即可成功配置Oh My Posh 可在Oh My Posh的官方文档中选择主题：https://ohmyposh.dev/docs/themes 更换主题只需修改xxxx.omp.json即可 退出后重新进入，可见配置生效 1oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\\jandedobbeleer.omp.json&quot; | Invoke-Expression 3.3 模块安装 首先安装PSReadLine，用于命令自动提示 1Install-Module -Name PSReadLine -AllowPrerelease -Scope CurrentUser -Force -SkipPublisherCheck 然后安装文件图标库，显示文件时可显示文件的颜色以及图标 1Install-Module -Name Terminal-Icons -Repository PSGallery 接下来就要在PowerShell的启动前参数中配置 12345oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\\jandedobbeleer.omp.json&quot; | Invoke-Expression# 导入文件图标模块Import-Module -Name Terminal-Icons# 命令行提示Tab选择功能Set-PSReadlineKeyHandler -Key Tab -Function MenuComplete 此时即配置完成 如果觉得打开速度慢，可以不导入文件图标模块","tags":["PowerShell"],"categories":["PowerShell"]},{"title":"整理书签","path":"/blog/2023-03-07-journal/","content":"整理书签的思考 整理书签浏览器书签断断续续存了好多了，可能达到上千个了，以前的存放方式感觉不太行，所以要整理，然而整理就要花费很多时间了。 就是因为一开始如果没有做好书签的存放位置和层次，后面就得一个一个看过来，导致这个麻烦的发生。不过还有原因应该是平时保存的一些文章类型的书签没有及时消化掉，而是直接丢到了书签文件夹里去。 这个问题在b站视频的收藏中也存在，很多人说“收藏从未停止，学习从未开始”，一个视频觉得不错就把它收藏了但是没有去看，那和没有收藏没啥区别。我以前也是收藏了很多的b站视频，后来意识到了这个问题。 现在的做法就是遇到一个好的视频，但是当前没有时间去看，就可以直接添加到稍后观看里去，这样我就会经常想起来去看完这个视频，所以现在收藏视频变得越来越少了。 不过还是难免会遇到稍后观看也吃灰的问题。我觉得这个问题的底层可能跟拖延症有关，我自己也是喜欢拖延的人，这个习惯真的不好，会导致很多应该要做的事没有及时完成，然后导致后续要做的事不断错位。 这个要想改正也只能看自己了。整理书签也不能马上整理完，需要每天持续一点点地整理了。 有一个插件或许有点作用，这个插件能间隔一段时间随机找一个书签然后提示出来，让我对它进行处理。可能对整理书签有些帮助 温故知新 - Microsoft Edge Addons","tags":["journal"],"categories":["日记"]},{"title":"时间消耗、一周结束","path":"/blog/2023-03-06-journal/","content":"对于时间的消耗，以及上课一周结束的思考 时间消耗这个周末，说实话，摆烂了好多，然后又在折腾各种乱七八糟的东西，时间花费了很多。其实我觉得，折腾东西是挺有意思的，但是可能是有一个曲线在，后面如果一直没办法解决问题，就会感觉无聊，想放弃了。唉，自己解决问题的速度还是太慢了，也是自己太菜的原因吧，还是得更多的学习才行。 对于学校课程，我的计划是还要去学一些东西的，但是其实寒假以及返校考试的时间段时就摆烂了，看来我真的是一个喜欢浪费时间的人。而且，看到很多人能充分利用好碎片时间，我就发现了自己没有这个能力，有时候就是一小段时间，觉得反正就那么点时间，干脆就休息吧！于是就休息了。 然后还有一个就是晚上熬夜，我基本上都是1点后睡觉了，这个只能说可能是因为事情太多，或者有什么事没做完，就顺带熬夜了。熬夜确实不太好，希望以后能早点睡觉吧。 一周结束上课一周结束了，这周因为是第一周还不知道后面的险恶吧，还算轻松，也许比上学期会轻松点。这周完成的事不算多，代码也没怎么写。下周加油了","tags":["journal"],"categories":["日记"]},{"title":"WSL的安装和简单使用","path":"/blog/2023-03-05-install-and-simple-use--WSL/","content":"基于b站和各个网上教程的WSL安装使用简单记录 WSL的安装和简单使用 可直接查阅微软官方文档：安装 WSL | Microsoft Learn 1.安装WSL1.1 前置条件和说明 首先要确保电脑的CPU开启了虚拟化 同时需要win10版本为 1903 或更高版本，内部版本为 18362 或更高版本 以下要安装的是WSL2，并且不是安装预览版的方式，而是旧版的进行手动的安装 旧版 WSL 的手动安装步骤 | Microsoft Learn 1.2 安装步骤和查看安装步骤 打开powershell， 启用“适用于 Linux 的 Windows 子系统”可选功能 1dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 同时 启用“虚拟机平台”可选功能 1dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 然后重启电脑 下载并安装 Linux 内核更新包： WSL2 Linux Kernel update package for x64 machines 接下来运行以下命令，将 WSL 2 设置为默认版本 1wsl --set-default-version 2 安装Linux发行版，直接在Microsoft Store中搜索WSL即可找到几个Linux发行版，此处安装的是ubuntu20.04，直接点击安装即可。 打开刚刚安装的ubuntu，因为是第一次安装，会需要进行一些初始设置。 需要输入用户名和密码 至此即安装完成，可以直接点击ubuntu图标进行使用 查看安装完成后的系统 输入screenfetch即可查看到Linux版本 同时这个ubuntu已经预装了git和python等等，均可查看 在powershell中，通过命令：wsl -l -v，可以查看子系统的运行状态。 2.使用Windows Terminal2.1 Windows Terminal安装Windows Terminal是一个比较好用的终端工具，可以集成powershell、cmd、wsl等 在Microsoft Store中直接搜索Windows Terminal，即可下载安装 可见可直接在其中打开wsl 2.2 Windows Terminal的美化 首先直接在Microsoft Store搜索 on-my-posh下载并安装 设置字体 下载一个Nerd Font字体并安装：https://www.nerdfonts.com 然后使用管理员身份打开Windows Terminal，Ctrl+ shift+, 打开wt的settings.json 对其中的 profiles.defaults下 添加以下字体配置，face设置的就是刚刚下载的字体名，最后保存 1234567&quot;profiles&quot;: &#123; &quot;defaults&quot;: &#123; &quot;font&quot;: &#123; &quot;face&quot;: &quot;下载的字体名&quot; 配置主题 直接中wt中输入以下命令打开powershell配置文件 如果找不到配置文件，直接按照$PROFILE输出的路径和文件名，新建一个即可。 一般powershell的配置文件在用户的文档目录下的\\WindowsPowerShell文件夹下 1notepad $PROFILE 在打开的文件中写入以下代码，然后保存退出 1oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\\json.omp.json&quot; | Invoke-Expression 然后wt中输入下面的命令，使配置生效。至此主题配置完成 1.$PROFILE 当然也可以修改主题，通过以下命令可找到各种主题，复制想要更换的主题名，重新打开powershell配置文件修改xxx.omp.json，xxx就是新的主题名，然后保存退出重复上一个步骤并重启即可 1Get-PoshThemes 3.为WSL配置zsh相比于默认的 Bash，zsh 有更多的自定义选项；然后oh-my-zsh是一个流行的 zsh 配置，可以自动配置zsh 首先安装zsh 1sudo apt install zsh 安装ohmyzsh，根据提示安装即可 1sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 如果无法访问到github，可进行如下操作： 在 https://site.ip138.com/raw.Githubusercontent.com/输入raw.githubusercontent.com查询IP地址 然后使用code /etc/hosts 修改hosts，添加刚刚的ip映射 使用ls -la可见zsh的配置文件.zshrc，可对zsh配置插件和主题，可查看ohmyzsh的wiki进行配置 比如以下安装一个ash-autosuggestions，cd进入.oh-my-zsh的plugin文件夹直接git clone对应的仓库即可 然后对 .zshrc修改，增加插件的名称即可 1234plugins=(\tgit\tzsh-autosuggestions) 这个插件可以根据历史记录和完成提示键入的命令 实现效果： 4.使用VSCode配合WSL编写代码 打开vscode后，可见其自动提示安装WSL相关插件，直接安装：Remote Development 在wt的wsl中创建一个目录，然后cd进入此目录 12mkdir WSLCodeDemocd WSLCodeDemo 此时使用以下命令试图通过vscode打开目录，可见其会自动安装 VS Code Server。接下来vscode就成功打开此目录了 同时安装插件后，可在远程资源管理器中直接打开WSL的文件目录，可以直接下载和上传文件 1code . 此时，在vscode中新建文件，就是在WSL中新建文件。即此时可在windows中通过vscode编辑和处理WSL内部的文件了。因为WSL默认安装了Python3，以下模拟编写Python 此时新建一个test.py，vscode会提示安装python插件，并在WSL上启用插件。此时写入简单程序 注意这里运行的vscode的插件分为本地和远程插件，可以在WSL上安装插件 1print(&#x27;Hello world!&#x27;) 然后vscode中直接运行程序，可见在wsl中成功输出了Hello world! 此时，就实现了在Windows中编写代码，而在Linux中直接运行的效果 5.文件的互相访问5.1 Windows访问WSL中的文件①使用vscode访问WSL中的文件 还是使用code命令，比如在WSL的根目录中输入命令，即可在vscode中查看到WSL根目录下的所有文件 同时vscode的远程资源管理器也可打开并访问文件 1code . ②使用Windows的资源管理器 可直接在我的电脑中查看并打开WSL的文件目录进行访问 同时也可以直接在WSL中输入命令使用资源管理器打开当前的目录 1explorer.exe . ③使用SSH连接 这和Linux中安装ssh服务，然后进行连接类似了 5.2 WSL访问Windows的文件 在WSL根目录下有一个mnt目录，进入此处可看到windows的每个盘了 123cd /mnt/ccd /mnt/dcd /mnt/e 此时可见windows中的文件，可用命令进行操作 6.WSLg 全称Windows Subsystem for Linux GUI WSLg是图形化的WSL，能够完成Ubuntu一小部分的图形显示，即可以运行WSL中的GUI程序，比如gedit WSLg本来只在win11上支持，但是win10的22H2版本也支持WSLg 如下打开gedit： 安装步骤 如果电脑是win11，或者是win10 22H2版本，可以使用。win10低版本首先需要更新系统升级到22H2 然后更新WSL 1wsl --update 更新完成后检查WSL的版本，能够正常显示，说明安装成功 1wsl --version 显示结果： WSL 版本： 1.1.3.0 内核版本： 5.15.90.1 WSLg 版本： 1.0.49 那么此时就可以愉快地使用WSLg了 比如安装gedit并使用gedit命令使用，安装后同时也可直接在windows开始目录下找到安装在WSL中的程序，点击也可直接运行 123sudo apt install gedit -ygedit 总的来说，有了WSLg后，WSL就更好用了，用起来的感觉挺神奇","tags":["vscode","Linux"],"categories":["Linux"]},{"title":"使用vscode编写C#代码","path":"/blog/2023-03-03-write-csharp-with-vscode/","content":"针对vscode如何编写C#代码进行了简单配置 使用vscode编写C#代码1.环境准备 在cmd或powershell中输入以下命令可查看电脑是否安装了.NET的相关SDK，以及查看版本 1dotnet --info 目前最新.NET版本是7 如果没有，则去微软官网进行下载并安装：下载 .NET(Linux、macOS 和 Windows) (microsoft.com) 安装步骤是无脑下一步 此时再输入上述命令，成功查看到.NET版本，即安装成功 2.vscode插件安装1、C# 装这个就能做大部分事了 2、vscode-solution-explorer 可自动生成解决方案和项目，不用输命令 3、C# XML Documentation 用于&#x2F;&#x2F;&#x2F;自动生成文档注释 4、.NET Core Add Reference 用于在项目上直接右键添加引用 5、Add Local .Net Reference 用于添加本地程序集引用 6、ASP.NET Core Switcher MVC项目时，可直接在视图和控制器之间切换 7、C# Extensions 用于右键自动添加C#类、接口、MVCController等 以上插件基本够用了，别的之后按需获取即可 3.创建一个项目 首先在Solution Explorer中选择Create New Solution，然后输入FirstDemo。可见创建了sln解决方案文件 然后在Solution Explorer中对解决方案右键——Add New Project，即可为当前解决方案添加项目 这里选择控制台应用程序，语言选择C#，然后对项目的命名，可以和解决方案同名，回车即可创建成功 打开项目下的Program.cs文件，vscode右下角会弹出创建launch和tasks文件的选项，点击yes即可。如果不创建将无法调试 此时生成的Program.cs如下，这是C#使用了顶级语句 12// See https://aka.ms/new-console-template for more informationConsole.WriteLine(&quot;Hello, World!&quot;); 不用顶级语句将会创建如下 123456789101112using System;namespace FirstDemo // Note: actual namespace depends on the project name.&#123; internal class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;Hello World!&quot;); &#125; &#125;&#125; 点击调试，即可成功运行输出“Hello World!”，说明成功","tags":["C#","vscode"],"categories":["DOTNET"]},{"title":"C#基础语法速成","path":"/blog/2023-03-02-CSharp-Basic-Grammar/","content":"这学期突然要学C#，那就学吧。以下笔记仅作自用 C#基础语法速成1.C#基本认识和特点 C#是微软公司发布的一种面向对象的、运行于 .NET Framework 和 .NET Core (完全开源，跨平台）之上的高级程序设计语言。 C#是一种安全的、稳定的、简单的、优雅的，由C和C++衍生出来的面向对象的编程语言。它在继承C和C++强大功能的同时去掉了一些它们的复杂特性。 C#是面向对象的编程语言。 C#可以用指针，但是不推荐也少用了 .NET和C#关系 .NET是C#运行环境，C#是开发语言， C# 可以编写在.NET 中运行的应用程序。 .NET公共语言运行时 (CLR) 是生成所有.NET 应用的基础，这个运行时还支持多种语言，有 C#、F# 和 Visual Basic 语言，但是C#算是主角 2.Visual Studio的安装和使用 Microsoft Visual Studio（简称VS)是美国微软公司的开发工具包系列产品VS是一个基本完整的开发工具集，是编写C＃程序或者说NET程序最常用的开发工具。 下载vs网址：https://visualstudio.microsoft.com/zh-hans/downloads/ vsi工作负载，根据自己的情况选择需要的安装模块，一般选择：ASP.NET和Web开发、.NET桌面开发、通用Windows平台开发、数据库存储和处理、Visual Studio扩展开发、.NET Core跨平台开发 2.1 开始第一个项目 就不创建控制台程序了，直接创建一个windows窗体应用，就不搞控制台应用了 选择C#、Windows、桌面，找到 WPF 应用(.NET Framwork) 2.2 VS的结构 一般习惯工具箱和解决方案资源管理器放在左边 别的好像也没啥了，随意了 3.cs文件结构 上面程序的各个部分： using System： using 关键字：用于在程序中包含System命名空间。一个程序一般有多个using语句。 namespace声明：一个namespace是一系列的类。WebApplication1命名空间 包含了类Program。 class声明：类Program包含了程序使用的数据和方法声明。类一般包含多个方法，方法定义了类的行为。类只有一个Main方法。 Main方法：是所有C#程序的入口点。Main方法说明当执行时类将做什么动作。 Main方法通过方法体中的语句指定它的行为。 以下几点值得注意： 一个cs文件的结构大约是由以上几个部分组成，但是根据不同的需求和作用，会有不同的内容 程序的执行从Main方法开始 4.C#基本语法 C#是一种面向对象的编程语言。在面向对象的程序设计方法中，程序由各种对象组成。相同种类的对象通常具有相同的类型。 C#是大小写敏感的 所有的语句和表达式必须以分号 ; 结尾 与Java不同的是，文件名可以不同于类的名称 4.1 关键字关键字，是对编译器有特殊意义的预定义保留标示符，它们不能在程序中用作标示符 using关键字 using关键字用于在程序中包含命名空间。一个程序可以包含多个using语句。 在任何C＃程序中的第一条语句都是： 1using System; class关键字 class关键字用于声明一个类。 4.2 注释 块注释 123/*这个程序演示C#语言的多行注释语法*/ 单行注释是用//符号表示。 1// test 文档注释用///符号表示 应用场合：声明的方法、类上 123456/// &lt;summary&gt;/// 这是主程序入口/// &lt;/summary&gt;/// &lt;param name=&quot;args&quot;&gt;需要传入的参数&lt;/param&gt;public static void Main(string[] args)&#123;&#125; 注释的作用： 解释：说明代码作用 注销：将暂时不需要的代码注销 总结： 不写注释是流氓 名字瞎起是扯淡 相比注销，注释意义更大 要做到别人一看就能看懂 4.3 变量 在C#中，每个变量都有一个特定的类型，不同类型的变量其内存大小也不尽相同。 C#的基本类型： 类型 举例 整数类型 byte(0-255)、short(-32768-32767)、int(-2*10^9-2*10^9)、long 浮点型 float、double 十进制类型 decimal 布尔类型 bool 字符类型 string、char 空类型 null float浮点类型，小数后需带f&#x2F;F decimal相当于精度更大的浮点型，但会有更多的性能损耗 浮点型之间的转换只有float转换为double一种，decimal无法直接转换到浮点型 5.C#语法进阶5.1 表达式 表达式由操作数(operand)和运算符(operator)构成。运算符的示例包括 ＋、- 、*、／ 和 new。操作数的示例包括文本、字段、局部变量和表达式。 当表达式包含多个运算符时，运算符的优先级(precedence)控制各运算符的计算顺序。例如，表达式x+y*z按x + (y * z)计算，因为＊运算符的优先级高于＋运算符。 （了解）大多数运算符都可以重载(overload,)。运算符重载允许指定用户定义的运算符实现来执行运算这些运算的操作数中至少有一个，甚至所有操作数都属于用户定义的类类型或结构类型。 下表总结了C#简单常用的运算符，并按优先级从高到低的顺序列出各运算符类别。同一类别中的 运算符优先级相同。 类别 表达式 说明 基本 x.m 成员访问 x(…) 方法和委托调用 x[…] 数组和索引器访问 new T(…) 对象和委托创建 new T(…){…} 使用初始值设定项创建对象 new {…} 匿名对象初始值设定项 new T[…] 数组创建 类别 表达式 说明 一元 +x 恒等 -x 求相反数 !x 逻辑求反 ~x 按位求反 ++x 前增量 –x 前减量 x++ 后增量 x– 后减量 (T)x 将x显式转换为类型T 类别 表达式 说明 二元 x*y、x&#x2F;y、x%y、x+y、x-y 乘除余加减（加号还有字符串串联） x&lt;&lt;y、x&gt;&gt;y 位左移、位右移 x&lt;y、x&gt;y、x&lt;&#x3D;y、x&gt;&#x3D;y 小于、大于、小于等于、大于等于 x is T 如果x为类型T，则返回 true，否则返回false x as T 返回转换为类型T的x，如果x不是T则返回null x&#x3D;&#x3D;y、x!&#x3D;y 等于、不等于 x&amp;y、x|y 整型按位AND&#x2F;OR，布尔逻辑AND&#x2F;OR x &amp;&amp; y 仅当x为true时，才对y求值 x ?? y 如果x为null，则计算结果为y，否则计算结果为x 类别 表达式 说明 三元 x?y:z 如果x为true，则对y求值；反之对z求值 x&#x3D;y 赋值 x&#x3D;x+y 复合赋值 (T x)&#x3D;&gt;y 匿名函数（lambda表达式） 5.2 分支语句if语句 1234567if(i&gt;1)&#123;&#125;else if(i&gt;2)&#123; &#125;else&#123; &#125; switch语句 12345678switch (i) &#123; case 1: Console.WriteLine(&#x27;1&#x27;); break; default: Console.WriteLine(&#x27;2&#x27;); break;&#125; for循环 123for (int k = 0; k &lt; 10; k++) &#123; Console.WriteLine(k);&#125; while循环 123456789int i3 = 0;while (true) &#123; i3++; if (i3 == 3) break;&#125;do &#123; Console.WriteLine(&#x27;1&#x27;);&#125; while (true); 这些看看就好了 5.3 数组 数组是一组相同类型的数据。 数组中的数据需要通过数字索引来访问。 数组的声明 数组的声明需要使用new关键字。 在声明数组时，可以使用｛｝来初始化数组中的元素。 如果在数组声明之初没有使用大括号来初始化数组中的元素，则需要指定数组的大小。 在声明初始化有元素的数组时，也可以指定数组大小。 12345678// 声明没有元素的数组int[] arr1 = new int[6];// 声明初始化有元素的数组int[] arr2 = new int[6] &#123; 1, 2, 3, 4, 5, 6 &#125;;// 在声明初始化有元素的数组时，也可以指定数组大小string[] strings = new string[3] &#123; &quot;1&quot;, &quot;2&quot;, &quot;3&quot; &#125;;// 不指定大小声明数组int[] arr3 = &#123; 1, 2, 3 &#125;; 通过索引获取数组中的元素 给数组指定长度时，数组准备存放多少元素，长度就设置为多少 用索引获取数组内的元素时，索引从0开始获取。 所以数组中最大的索引数字，比指定数组长度小1。 这些看看就好了 5.4 类型转换 (int)表示使用显式强制转换，是一种类型转换，C#默认整型是int32，因此使用此方法转成int32位，不遵循四舍五入，于是只截取到了整数部分 (int)5.21 &#x2F;&#x2F;输出5 ①int.Parse()：只支持将string类型转成int，Parse就是把String类型转换成int、char、double等 也就是*.Parse(string)括号中的一定要是string类型。 1234String st = &quot;5.21&quot;;double n = 5.21;int.Parse(st); //输出5int.Parse(n); //报错 ②Convert.Tolnt32(double value)：不完全遵循四舍五入，如果value为两个整数中间的数字，则返回二者中的偶数 注意： Convert.Tolnt32() 和 int.Parset() 对于空值(null)的处理不同，Convert.Tolnt32(nul)会返回0而不会产生任何异常，但int.Parse(null)则会产生异常 123456Console.WriteLine(Convert.ToInt32(4.3));//四舍五入，输出4Console.WriteLine(Convert.ToInt32(4.5));//第一位小数为5时，4.5在4和5之间，输出偶数4Console.WriteLine(Convert.ToInt32(4.53));//四舍五入，输出5Console.WriteLine(Convert.ToInt32(5.3));//四舍五入，输出5Console.WriteLine(Convert.ToInt32(5.5));//第一位小数为5时，5.5在5和6之间，输出偶数6Console.WriteLine(Convert.ToInt32(5.53));//四舍五入，输出6 5.5 函数 函数好比是对象的动作行为。 在定义函数要想好函数所承担的作用，职责（作用）越单一越好。 函数命名规范 函数命名使用大驼峰命名，即开头首字母大写 多个单词拼接时，所有单词首字母大写 123Add();AddCount();GetUserInfo(); 函数的参数设置&amp;传参行为&amp;返回值 参数可认为是外部需要函数帮忙处理的数据。 外部通过传递参数的形式，将需要处理的数据交给函数处理。 函数返回值可以认为是外部调用某种行为后得到的一种反馈。 12345678910/// &lt;summary&gt;/// 加法方法/// &lt;/summary&gt;/// &lt;param name=&quot;firstCount&quot;&gt;数字1&lt;/param&gt;/// &lt;param name=&quot;secondCount&quot;&gt;数字2&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public int Add(int firstCount, int secondCount) &#123; int total = firstCount + secondCount; return total;&#125; 5.5.1 参数修饰符①无修饰符：如果一个参数没有用参数修饰符标记，则认为它将按值进行传递，这将意味着被调用的方法收到原始数据的一份副本。 即上端调用方法后，下端修改传来的参数不会对原数据造成影响，即参数在方法中只复制了副本。 示例：方法不对原字符串影响修改 123456789string str1 = &quot;test1&quot;;SendMessage(str1);void SendMessage(string msg) &#123; msg = &quot;change&quot;; Console.WriteLine(msg); // change&#125;Console.WriteLine(str1); // test1 ②out：输出参数由被调用的方法赋值，因此按引用传递，如果被调用的方法没有给输出参数赋值，就会出现编译错误。 方法中out修饰的参数，一定要在方法内得到赋值 调用者可不赋初值，甚至可直接将声明变量写在方法调用传参中 即上下端的参数指向同一个地址，修改都会受到影响。 out最大的用途就是调用者只使用一次方法的调用就能获得多个返回值。 在C#7.0中要实现一次方法的调用就能获得多个返回值，建议使用元组。 示例： 1234567891011121314151617181920/* 1.方法中的修改作用到原字符串 */string str1 = &quot;test1&quot;;SendMessage(out str1);void SendMessage(out string msg) &#123; msg = &quot;change&quot;; Console.WriteLine(msg); // change&#125;Console.WriteLine(str1); // change/* 2.调用方法返回多个返回值 */// 这里直接在方法调用的out参数上声明变量string res = SellHouse(100, 1000, out string wantPrice);Console.WriteLine(res);Console.WriteLine(wantPrice);string SellHouse(int area, int price, out string wantPrice) &#123; wantPrice = &quot;出价&quot; + (area * price - 1); return &quot;张三买房&quot;;&#125; ③ref：调用者必须赋初值，并且可以由被调用的方法可选的重新赋值（数据是按引用传递的）。如果被调用的方法未能给ref参数赋值，也不会有编译器错误。 方法中ref修饰的参数，方法内未得到赋值不报错，和out不同。 但是调用者必须赋初值，否则报错。 示例： 12345678string str1 = &quot;test&quot;;//string str1; 报错SendMessage(ref str1);void SendMessage(ref string msg) &#123; msg = &quot;test2&quot;; Console.WriteLine(msg); // test&#125;Console.WriteLine(str1); // test ④params：这个参数修饰符允许将一组可变的数量的参数作为单独的逻辑参数进行传递，方法只能有一个params修饰符，而且必须是方法的最后一个参数。（就是可变参数） 总结out和ref的区别 out修饰的参数必须在方法内修改，而ref可以修改也可以不修改 out在传入参数的时候，参数是局部变量的话，可以不用赋值，因为out一定会对其进行赋值 out参数方法中必须赋值，所以可不需要初始值 而ref修饰的参数，在实参必须有初始值才能调用。因为ref修饰的不一定会给它赋值 因为方法中不一定给ref参数赋值，所以一定要有初始值 out修饰参数可在调用方法时直接声明变量，ref则不行 6.面向对象编程（OOP）6.1 面向对象编程基本概念 面向对象编程一一Object Oriented Programming简写OOP 之前所接触到的编程方式叫做面向过程 面向过程和面向对象是两种不同的编程方式 对比面向过程的特点，可以更好的了解什么是面向对象 过程和函数 过程是早期的一个编程概念 过程类似于函数，只能执行，但是没有返回值 函数不仅能执行，还可以返回结果 面向过程——强调怎么做？ 把完成某一个需求的所有步骤从头到尾逐步实现 根据开发需求，将某些功能独立的代码封装成一个又一个函数 最后完成的代码，就是顺序的调用不同的函数 特点： 注重步骤与过程，不注重职责分工 如果需求复杂，代码会变得很复杂 复杂项目，没有固定的套路，难度很大 比如一个主函数，自顶向下调用多个子函数，这几个子函数又会去调用多个子子函数，形成树的结构 面向对象逻辑——强调谁来做？ 相比较函数，面向对象是更大的封装，根据职责，在一个对象中封装多个方法 在完成某一个需求前，首先确定职责，要做的事情（方法） 根据职责确定不同的对象，在对象内部封装不同的方法（多个） 最后完成代码，就是顺序的让不同的对象调用不同的方法 特点： 注重对象和职责，不同的对象承担不同的职责 更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供固定套路 需要在面向过程基础上，再学习一些面向对象的语法 6.2 类和对象概念 类和对象是面向对象编程的两个核心概念 类是对一群具有相同特征或者行为的事物的一个统称，是抽象的，不能直接使用 特征被称为属性 行为被称为方法 例如：类相当于制汽车是的图纸，是一个模板，是负责创建对象的 对象 对象是由类创造出来的一个具体存在，可以直接使用 由哪一个类创造出来的对象，就拥有在哪一个类中定义的属性和方法 对象就相当于用图纸制造的汽车 先有类，再有对象 类和对象的关系 类是模板，对象是根据类这个模板创建出来的，应该先有类，再有对象 类只有一个，而对象可以有很多个 不同的对象之间属性的具体内容可能各不相同 类中定义了什么属性和方法，对象中就有什么属性和方法，不可能多，也不可能少 6.3 类的设计 在使用面向对象开发前，应该首先分析需求，确定一下程序中需要包含哪些类 在程序开发中要设计一个类，通常需要满足以下三个要素： 1.类名这类事物的名称，满足大驼峰命名法 2.属性这类事物具有什么样的特征 3.方法这类事物具有什么样的行为 类名的确定 名词提炼法分析整个业务流程，出现的名词，通常就是找到的类。 属性和方法的确定 对对象的特征，描述通常可以定义成属性。 对象具有的行为通常可以定义为方法。注：方法一般是动作即动词 提示：需求没有涉及的属性或者方法在设计类时，不需要考虑，即可忽略。 6.4 类和对象的使用6.4.1 声明类 声明一个类需要使用class关键字 类的属性及方法写在&#123;&#125;中 步骤：vs中右键项目名——添加——类 123public class Person &#123; &#125; 6.4.2 声明属性 属性在C#中较为独特，它既不同于方法，也不同于字段。 属性依旧遵循大驼峰命名法 属性最常用的书写方法：public int Age &#123;get; set;&#125; 如果属性中具有get关键字，说明可以获取该属性的值。 如果属性中具有set关键字，说明可以向该属性设置值。 如果没有get和set关键字，则无法获取属性值以及设置属性值 1234567namespace Csharp_Class &#123; public class Person &#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public int Height &#123; get; set; &#125; &#125;&#125; vs快捷编码 - 自动属性模板：输入props，按2次Tab，自动生成一个属性声明的模板 6.4.3 声明方法 详见函数初识 1234567891011121314namespace Csharp_Class &#123; public class Person &#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public int Height &#123; get; set; &#125; public void Eat() &#123; MessageBox.Show(&quot;吃&quot;); &#125; public void Run() &#123; MessageBox.Show(&quot;跑&quot;); &#125; &#125;&#125; 6.4.4 实例化 类使用关键字new实例化对象。 一个类可以实例化多个对象。 对象可以使用类定义的属性和方法。 1234567891011121314151617/* 在另一个类中实例化前面的类，并使用 */namespace Csharp_Class &#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void Form1_Load(object sender, EventArgs e) &#123; Person p = new Person(); p.Name = &quot;zhangsan&quot;; p.Age = 29; p.Eat(); p.Run(); &#125; &#125;&#125; 6.4.5 对象初始化器 在实例化之时，就对其属性进行赋值。 即实例化后直接跟随一个大括号，其中写明属性的赋值，注意这之中分隔符为逗号 可以不带括号了，直接连接大括号 12345678910111213141516/* 在另一个类中实例化前面的类，并使用 */namespace Csharp_Class &#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void Form1_Load(object sender, EventArgs e) &#123; // 拓展：对象初始化器：在实例化之时，就对其属性进行赋值 Person p2 = new Person() &#123; Age = 18, Name = &quot;zhangsan&quot; &#125;; &#125; &#125;&#125; 6.4.6 访问修饰符 public：公有的所有的类都可以访问 private：私有的当前类内部可访问 protected：受保护的当前类以及继承他的子类可访问 internal：内部的只限于本项目内访问，其他的不能访问。 protected internal：内部保护访问只能是本项目内部或子类访问其他类不能访问 访问级别约束： 父类子类访问修饰符要保持一致 方法的访问修饰符 要和 方法参数的访问修饰符 保持一致 注意：类的访问级别 默认为隐式私有，因此需要加上public才可让外部访问 6.4.7 static 静态方法、属性 静态属性和方法 通过**static关键字**修饰 静态属性和方法 可以通过类型直接获取，非静态则必须通过实例化的对象获取 静态类 静态类通过**static关键字**修饰 一般情况下类型不需要使用静态修饰，只有当类型中存在扩展方法时需要使用静态类 7.集合&amp;字典的使用7.1 集合的使用 集合与数组比较类似，都用于存放一组值 7.1.1 数组的优劣分析优势 数组在内存中是连续存储的，所以它的索引速度是非常的快，而且赋值与修改元素也很简单。 劣势 在数组的两个数据间插入数据很麻烦 在声明数组的时候，必须同时指明数组的长度，数组的长度过长，会造成内存浪费，数组和长度过短，会造成数据溢出的错误 7.1.2 ArrayList的使用 ArrayList是 .NET Framework 提供的用于数据存储和检索的专用类 它是命名空间 System.Collections下的一部分 ArrayList的优势 ArrayList的大小是按照其中存储的数据来动态扩充与收缩的 在声明 ArrayList 对象时并不需要指定它的长度 ArrayList可以很方便的进行数据的添加，插入和移除 123456ArrayList arrayList = new ArrayList();arrayList.Add(123);arrayList.Add(&quot;abc&quot;);arrayList.Insert(1, 123 + &quot;abc&quot;);arrayList.RemoveAt(0);arrayList.Remove(&quot;abc&quot;); 从上面示例看，ArrayList好像是解决了数组中所有的缺点，那么它应该就是完美的。 可是在C#2.0 后又出现了List集合，这是为何？ ArrayList的劣势 ArrayList在存储数据时时是使用 object类型 进行存储的 object是所有类的父类（父类可接收子类的对象） ArrayList不是类型安全的，使用时很可能会出现类型不匹配的错误 就算都有插入了统一类型的数据，但在使用的时候，也需要将它们从object转化为对应的原类型来处理 ArrayList的存储存在 装箱 和 拆箱 操作，导致其性能低下 7.1.3 装箱与拆箱的概念 装箱：将比如int类型或者string等 不同类型的对象 通过 隐式转换 赋给object对象。（子赋给父） 12int i = 123;object o = i; 拆箱：将 object对象 通过显式转换 赋给int类型的变量（父转换为子） 显式转换的前提是，被转换者的类型确实是这个类型。否则报错 12object o = 123;int i = (int)o; 装箱与拆箱的过程会产生较多的性能损耗。 正是因为ArrayList存在 不安全类型 与 装箱拆箱 的缺点，所以在C#2.0后出现了泛型的概念。 泛型的概念在此先不多做表述，可以简单理解成：限制集合只能够存储单一类型数据的一种手段 7.1.4 List集合 目前只学习List集合这一种类型即可，以此为突破口，以后再学习其他集合就会非常容易 List集合的声明 List集合与ArrayList由于都继承成了相同的接口，故使用与ArrayList相似。 在声明List集合时，需要同时为其声明List集合内数据的对象类型 示例：List&lt;int&gt; intList = new List&lt;int&gt;() 接口：限制和规定类型行为即类型方法的一种手段。 12345678910111213List&lt;int&gt; ints = new List&lt;int&gt;();ints.Add(1);//ints.Add(&quot;abc&quot;);ints[0] = 2;ints[1] = 3;ints.Insert(0, 5);ints.RemoveAt(0);ints.Remove(2);// 对象初始化器方式List&lt;int&gt; ints2 = new List&lt;int&gt; &#123; 1,2,3,4,5&#125;;ints2.Clear(); 上例中，如果往List集合中插入string字符串”abc”，系统就会报错，且不能通过编译。这样就避免了前面讲的类型安全问题与装箱拆箱的性能问题 在List集合中使用自己创建的类 12345678910111213141516171819202122internal class Person &#123; public int Age &#123; get; set; &#125; public string Name &#123; get; set; &#125; public int Height &#123; get; set; &#125;&#125;List&lt;Person&gt; people = new List&lt;Person&gt;();Person person1 = new Person &#123; Age = 18, Height = 178, Name = &quot;张三&quot;&#125;;people.Add(person1);people.Add(person1);people.Add(new Person &#123; Age = 18, Height = 178, Name = &quot;张三&quot;&#125;);Person person2 = people[0];people.RemoveAt(0);people.Remove(person1); 注意remove方法删除的是指定地址的对象，而每次new出来的对象即使属性相同但是地址不同，还是不同的对象，那么就不能同时被删除掉 总结 集合与数组比较类似，都用于存放一组值 集合中提供了特定的方法能直接操作集合中的数据，并提供了不同的集合类来实现特定的功能 简单的说就是数组的升级版。 他可以动态的对集合的长度（也就是集合内最大元素的个数）进行定义和维护 List泛型的好处指通过允许指定 泛型类或方法 操作的 特定类型， 减少了类型 强制转换 的需要和运行时错误的可能性，泛型提供了类型安全，但没有增加开销。（不会发生装箱和拆箱） 7.2 字典的使用 即一个萝卜一个坑，每一个标记有不重复编号的坑都只能放一个萝卜或者其它东西 Dictionary有 key(键) 和 value(值)，一个键只能对应一种值 一个value可以有很多key，但是key是唯一的。 比如学生是唯一的，成绩不唯一 总结：键唯一，值不唯一 Dictionary声明 在声明Dictionary字典时，需要同时为其声明Dictionary字典内键与值的类型。 示例：Dictionary&lt;int,string&gt; dictionary = new Dictionary&lt;int, string&gt;() 123456789101112131415Dictionary&lt;int, string&gt; dictionary = new Dictionary&lt;int, string&gt;();// 方式一：Add方法赋值dictionary.Add(1, &quot;98分&quot;);dictionary.Add(2, &quot;92分&quot;);dictionary.Add(3, &quot;89分&quot;);dictionary.Add(1, &quot;88分&quot;); // 运行后系统会报错（重复键）// 方式二：索引器赋值dictionary[1] = &quot;88分&quot;; //系统不报错dictionary[4] = &quot;99分&quot;;// 方式三：对象初始化器Dictionary&lt;string, string&gt; dictionary2 = new Dictionary&lt;string, string&gt; &#123; &#123; &quot;A&quot;, &quot;aa&quot; &#125;, &#123; &quot;B&quot;, &quot;bb&quot; &#125;, &#123; &quot;C&quot;, &quot;cc&quot; &#125;&#125;; Dictionary取值和删除 Dictionary索引器中写的键，获取到的是单个的对应值 1234567891011//获取键为1的值// 方式一：索引器取值string value = dictionary[1];// 方式二：foreach遍历取值（这里遍历项就是每一个小键值对，用KeyValuePair专门定义可设置或检索的键值对）foreach (KeyValuePair&lt;int, string&gt; item in dictionary) &#123; string value2 = item.Value;&#125;// 移除键为1的键值对dictionary.Remove(1); 总结 键与值可以是任何类型， 但是键必须在设置时是唯一的， 而值可以不唯一 使用Add(）方法添加键值对，不可添加已有的键名 索引模式可以 新赋值 也可以 修改 已有的键值（注意不是下标） 字典是键值对的集合 7.3 foreach使用 foreach就是传说中的增强for循环或者称作foreach循环 foreach对遍历字典或集合具备天然优势， 效率高过for循环 它循环的对象继承了迭代器 foreach操作数组 12345int[] ints = &#123; 1,2,3,4 &#125;;foreach (int item in ints) &#123; // 每次循环，其item都是整型数组中的一个元素 MessageBox.Show(item.ToString());&#125; foreach操作集合 12345List&lt;int&gt; intList = new List&lt;int&gt; &#123; 1,2,3,4 &#125;;foreach (int item in intList) &#123; // 每次循环，其item都是List集合中的一个元素 MessageBox.Show(item.ToString());&#125; foreach操作字典 这里的item就是一个小键值对 1234foreach (KeyValuePair&lt;int, string&gt; item in dictionary) &#123; int key0 = item.Key; string value0 = item.Value;&#125; 使用var类型推断 var关键字的作用是推断类型，声明的时候必须赋值。赋值到什么类型就成为什么类型 12345List&lt;int&gt; listInt = new List&lt;int&gt; &#123; 1, 2, 3, 4 &#125;;foreach (var item in listInt)&#123; Console.WriteLine(item);&#125; 那么至此C#大概常用的简单语法就学完了","tags":["C#"],"categories":["DOTNET"]},{"title":"开始","path":"/blog/2023-02-28-start/","content":"从博客的博客的博客中看到了以下内容，我觉得确实，随便写点东西也会有用的。 日记的作用作者链接: 对6年日记|的观察ᕕ( ᐛ )ᕗ 赫尔曼的博客 (bearblog.dev) 编程有一个术语叫做”橡皮鸭”，指的是这样一种场景: 程序员遇到一个特别困难的问题，有时会找到其他人，向他人描述这个问题，希望其他人给点建议。 但是，在描述问题时，为了让他人理解，程序员会逐渐理清思路，有时还没等其他人给出建议，自己就悟到应该怎么解决了。 这样的场景中，其他人的作用完全可以用一个橡皮鸭代替。如果遇到想不清楚的问题，就可以尝试对着一只橡皮鸭来解释这个问题，想象怎么描述，可以让橡皮鸭理解这个问题。 在某些方面，作者觉得，日记就是他的橡皮鸭。 在日记里面描述那些困难的问题，可以帮助理清思路，构建想法，反思自己的做法和情绪，并锻炼自己更好的表达能力。 他说他已经坚持写日记六七年。","tags":["journal"],"categories":["日记"]},{"title":"便笺","path":"/notes/index.html","content":"TOC便笺"},{"path":"/about/index.html","content":"关于本站本站就是一个普通的博客网站，没啥东西。就目前个人而言，还啥都不会"}]